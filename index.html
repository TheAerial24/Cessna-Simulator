<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Plane - Inverted Pitch (Flight Sim)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; }
        
        /* UI Container */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; padding: 20px; box-sizing: border-box;
            font-family: 'Courier New', Courier, monospace;
        }

        /* Controls Instructions */
        #instructions {
            color: white; background: rgba(0, 0, 0, 0.6); padding: 15px;
            border-radius: 8px; display: inline-block;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        /* Altimeter Display */
        #altimeter-panel {
            position: absolute; top: 20px; right: 20px;
            background: rgba(0, 0, 0, 0.6); color: #00ff00;
            padding: 10px 20px; border-radius: 8px;
            font-size: 24px; font-weight: bold;
            border: 2px solid #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
            text-shadow: 0 0 5px #00ff00;
        }

        h2 { margin-top: 0; font-family: sans-serif; }
        p { margin: 5px 0; font-family: sans-serif; }
        .key { color: #ffd700; font-weight: bold; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="instructions">
            <h2>Flight Controls (Sim Style)</h2>
            <p><span class="key">↑ Up Arrow</span> - Nose Down (Dive)</p>
            <p><span class="key">↓ Down Arrow</span> - Nose Up (Climb)</p>
            <p><span class="key">← / →</span> - Bank Left / Right</p>
            <p><span class="key">Space</span> - Turbo Boost</p>
            <p><span class="key">Shift</span> - Air Brake</p>
        </div>

        <div id="altimeter-panel">
            ALT: <span id="altimeter-value">0</span> FT
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. SETUP SCENE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 500);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- 2. LIGHTING ---
        const ambientLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(100, 200, 50);
        dirLight.castShadow = true;
        
        // Shadow settings
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        const d = 100;
        dirLight.shadow.camera.left = -d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = -d;
        dirLight.shadow.camera.far = 500;
        scene.add(dirLight);

        // --- 3. CREATE THE PLANE ---
        let propeller;

        function createPlane() {
            const planeGroup = new THREE.Group();

            const bodyMat = new THREE.MeshPhongMaterial({ color: 0xe74c3c, flatShading: true });
            const whiteMat = new THREE.MeshPhongMaterial({ color: 0xecf0f1, flatShading: true });
            const darkMat = new THREE.MeshPhongMaterial({ color: 0x2c3e50, flatShading: true });

            // Body
            const bodyGeo = new THREE.ConeGeometry(0.8, 4, 8);
            bodyGeo.rotateX(Math.PI / 2);
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.castShadow = true;
            planeGroup.add(body);

            // Cockpit
            const cockpitGeo = new THREE.BoxGeometry(0.9, 0.9, 1.2);
            const cockpit = new THREE.Mesh(cockpitGeo, darkMat);
            cockpit.position.set(0, 0.4, 0.5);
            cockpit.castShadow = true;
            planeGroup.add(cockpit);

            // Wings
            const wingGeo = new THREE.BoxGeometry(6, 0.1, 1.5);
            const wings = new THREE.Mesh(wingGeo, whiteMat);
            wings.position.set(0, 0, 0.5);
            wings.castShadow = true;
            wings.receiveShadow = true;
            planeGroup.add(wings);

            // Tail
            const tailGeo = new THREE.BoxGeometry(2, 0.1, 1);
            const tail = new THREE.Mesh(tailGeo, whiteMat);
            tail.position.set(0, 0, 1.6);
            tail.castShadow = true;
            planeGroup.add(tail);

            const rudderGeo = new THREE.BoxGeometry(0.1, 1.2, 1);
            const rudder = new THREE.Mesh(rudderGeo, whiteMat);
            rudder.position.set(0, 0.6, 1.6);
            rudder.castShadow = true;
            planeGroup.add(rudder);

            // Propeller
            propeller = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.1, 0.2), darkMat);
            propeller.position.set(0, 0, -2);
            planeGroup.add(propeller);

            return planeGroup;
        }

        const airplane = createPlane();
        scene.add(airplane);

        // --- 4. ENVIRONMENT ---
        const floorGeo = new THREE.PlaneGeometry(2000, 2000);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x8BC34A });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -50;
        floor.receiveShadow = true;
        scene.add(floor);

        const gridHelper = new THREE.GridHelper(2000, 100, 0xffffff, 0x555555);
        gridHelper.position.y = -49.9;
        scene.add(gridHelper);

        // Obstacles
        const geom = new THREE.BoxGeometry(10, 10, 10);
        const mat = new THREE.MeshStandardMaterial({ color: 0x3498db });
        for (let i = 0; i < 60; i++) {
            const cube = new THREE.Mesh(geom, mat);
            cube.position.set(
                (Math.random() - 0.5) * 800,
                (Math.random() * 200) - 40,
                (Math.random() - 0.5) * 800
            );
            cube.castShadow = true;
            cube.receiveShadow = true;
            scene.add(cube);
        }

        // --- 5. CONTROLS ---
        const keys = { 
            ArrowUp: false, ArrowDown: false, 
            ArrowLeft: false, ArrowRight: false, 
            Space: false, Shift: false 
        };

        window.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.code)) keys[e.code] = true; 
            if (e.key === "ArrowUp") keys.ArrowUp = true;
            if (e.key === "ArrowDown") keys.ArrowDown = true;
            if (e.key === "ArrowLeft") keys.ArrowLeft = true;
            if (e.key === "ArrowRight") keys.ArrowRight = true;
            if (e.code === 'Space') keys.Space = true;
            if (e.key === 'Shift') keys.Shift = true;
        });

        window.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.code)) keys[e.code] = false;
            if (e.key === "ArrowUp") keys.ArrowUp = false;
            if (e.key === "ArrowDown") keys.ArrowDown = false;
            if (e.key === "ArrowLeft") keys.ArrowLeft = false;
            if (e.key === "ArrowRight") keys.ArrowRight = false;
            if (e.code === 'Space') keys.Space = false;
            if (e.key === 'Shift') keys.Shift = false;
        });

        // --- 6. PHYSICS LOOP ---
        let currentSpeed = 0;
        const speedProps = { base: 0.8, boost: 1.8, brake: 0.2, accel: 0.05 };
        const altimeterEl = document.getElementById('altimeter-value');

        function updatePlane() {
            // 1. Speed
            let targetSpeed = speedProps.base;
            if (keys.Space) targetSpeed = speedProps.boost;
            else if (keys.Shift) targetSpeed = speedProps.brake;
            
            currentSpeed = THREE.MathUtils.lerp(currentSpeed, targetSpeed, speedProps.accel);

            // 2. Rotation
            // Inverted Pitch: Up Key = Rotate Positive (Nose Down), Down Key = Rotate Negative (Nose Up)
            if (keys.ArrowUp) airplane.rotateX(0.04); 
            if (keys.ArrowDown) airplane.rotateX(-0.04);

            if (keys.ArrowLeft) {
                airplane.rotateZ(0.05);
                airplane.rotateY(0.02);
            }
            if (keys.ArrowRight) {
                airplane.rotateZ(-0.05);
                airplane.rotateY(-0.02);
            }

            // 3. Move Forward (Local Y axis is forward for this model)
            airplane.translateY(-currentSpeed);

            // 4. Propeller
            if(propeller) propeller.rotation.z += 0.8 * (currentSpeed + 0.5);

            // 5. Update Altimeter UI
            // Ground is at -50. So Altitude = plane.y + 50
            const altitude = Math.max(0, Math.floor(airplane.position.y + 50));
            altimeterEl.innerText = altitude;
        }

        function updateCamera() {
            const offset = new THREE.Vector3(0, 8, 20); 
            const targetPos = offset.applyMatrix4(airplane.matrixWorld);
            camera.position.lerp(targetPos, 0.1);
            const lookAtOffset = new THREE.Vector3(0, 0, -10);
            const lookAtPos = lookAtOffset.applyMatrix4(airplane.matrixWorld);
            camera.lookAt(airplane.position);
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePlane();
            updateCamera();
            
            // Keep shadow camera near player
            dirLight.position.x = airplane.position.x + 50;
            dirLight.position.z = airplane.position.z + 50;
            dirLight.target = airplane;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
