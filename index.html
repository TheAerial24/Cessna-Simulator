<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cessna 172 - Free Flight</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; padding: 20px; box-sizing: border-box;
            font-family: 'Courier New', Courier, monospace;
        }

        #instructions {
            color: white; background: rgba(0, 0, 0, 0.7); padding: 15px;
            border-radius: 8px; display: inline-block;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            border: 1px solid #555;
        }

        #dashboard-ui {
            position: absolute; top: 20px; right: 20px;
            background: rgba(0, 0, 0, 0.7); color: #00ff00;
            padding: 15px; border-radius: 8px;
            font-size: 20px; font-weight: bold;
            border: 2px solid #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
            text-align: right;
            line-height: 1.5;
        }

        #msg-overlay {
            display: none; position: absolute; top: 80%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            padding: 10px 30px; border: 2px solid #00ff00;
            font-weight: bold; text-shadow: 1px 1px 0 black;
            background: rgba(0,0,0,0.8); color: #00ff00;
            font-size: 24px;
        }

        .key { color: #ffd700; font-weight: bold; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="instructions">
            <h2>Cessna 172 Controls</h2>
            <p><span class="key">0</span> - Cut Engine</p>
            <p><span class="key">1 - 9</span> - Throttle %</p>
            <p><span class="key">Q</span> - Full Power</p>
            <p><span class="key">↑ / ↓</span> - Pitch Up / Down</p>
            <p><span class="key">← / →</span> - Bank Left / Right</p>
            <p><span class="key">C</span> - Toggle View</p>
        </div>

        <div id="dashboard-ui">
            THR: <span id="throttle-ui">0</span>%<br>
            SPD: <span id="speed-ui">0</span> KTS<br>
            ALT: <span id="alt-ui">0</span> FT
        </div>

        <div id="msg-overlay">PERFECT LANDING</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 100, 4000);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 10000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- 2. LIGHTING ---
        const ambientLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(200, 500, 300);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 4096; 
        dirLight.shadow.mapSize.height = 4096;
        const d = 1500;
        dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
        scene.add(dirLight);

        // --- 3. CESSNA 172 MODEL (ACCURATE SHAPE) ---
        let propeller, yokeMount, yokeWheel, firstPersonRig;
        
        function createCessna() {
            const planeGroup = new THREE.Group();
            
            // Materials
            const paintMat = new THREE.MeshPhongMaterial({ color: 0xffffff, shininess: 50 }); 
            const interiorMat = new THREE.MeshPhongMaterial({ color: 0xd6cfa2, flatShading: true }); 
            const dashMat = new THREE.MeshPhongMaterial({ color: 0x2c3e50, flatShading: true }); 
            const blackMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
            const chromeMat = new THREE.MeshPhongMaterial({ color: 0xcccccc, shininess: 100 });
            const glassMat = new THREE.MeshPhongMaterial({ 
                color: 0x88ccff, 
                opacity: 0.25, 
                transparent: true, 
                side: THREE.DoubleSide 
            });
            const propMat = new THREE.MeshPhongMaterial({ color: 0x222222 });

            // --- A. FUSELAGE (Extruded Shape Method) ---
            const shape = new THREE.Shape();
            
            // Accurate Profile (Side view)
            shape.moveTo(0, 0.5); 
            shape.lineTo(0, -0.5); 
            shape.lineTo(-6, -0.5); 
            shape.lineTo(-8, 0.5);  
            shape.lineTo(-8, 1.8);
            shape.lineTo(-5.5, 2.0); // Base of windshield
            shape.lineTo(-4.0, 3.2); // Top of windshield
            shape.lineTo(-1.0, 3.2); // Roof
            shape.lineTo(5.0, 1.2);  // Tail taper
            shape.lineTo(7.0, 1.2);
            shape.lineTo(8.5, 5.0);  // Tail top
            shape.lineTo(9.5, 5.0); 
            shape.lineTo(9.5, 0.8); 
            shape.lineTo(0, 0.5);

            const extrudeSettings = {
                steps: 1, depth: 2.4, bevelEnabled: true,
                bevelThickness: 0.1, bevelSize: 0.1, bevelSegments: 2
            };

            const fuselageMesh = new THREE.Mesh(new THREE.ExtrudeGeometry(shape, extrudeSettings), paintMat);
            fuselageMesh.position.set(0, 0, -1.2); 
            fuselageMesh.rotation.y = -Math.PI / 2;
            fuselageMesh.castShadow = true;
            planeGroup.add(fuselageMesh);

            // --- B. GLASS ---
            // Windshield
            const windShield = new THREE.Mesh(new THREE.PlaneGeometry(2.6, 2.2), glassMat);
            windShield.position.set(0, 2.5, -4.6);
            windShield.rotation.x = -0.7; 
            planeGroup.add(windShield);

            // Side Windows
            const sideWinGeo = new THREE.PlaneGeometry(3.0, 1.2);
            const winL = new THREE.Mesh(sideWinGeo, glassMat);
            winL.position.set(1.26, 2.4, -2.5); winL.rotation.y = -Math.PI/2; planeGroup.add(winL);
            const winR = new THREE.Mesh(sideWinGeo, glassMat);
            winR.position.set(-1.26, 2.4, -2.5); winR.rotation.y = Math.PI/2; planeGroup.add(winR);

            // Rear Windows
            const rearWinGeo = new THREE.PlaneGeometry(1.5, 1.0);
            const rWinL = new THREE.Mesh(rearWinGeo, glassMat);
            rWinL.position.set(1.26, 2.4, -0.2); rWinL.rotation.y = -Math.PI/2; planeGroup.add(rWinL);
            const rWinR = new THREE.Mesh(rearWinGeo, glassMat);
            rWinR.position.set(-1.26, 2.4, -0.2); rWinR.rotation.y = Math.PI/2; planeGroup.add(rWinR);

            // --- C. WINGS ---
            const wings = new THREE.Mesh(new THREE.BoxGeometry(36, 0.5, 5.5), paintMat);
            wings.position.set(0, 3.4, -2.5); 
            wings.castShadow = true; planeGroup.add(wings);

            // Struts
            const strutGeo = new THREE.CylinderGeometry(0.1, 0.1, 7);
            const strutL = new THREE.Mesh(strutGeo, paintMat);
            strutL.position.set(4, 1.0, -2.5); strutL.rotation.z = -0.8; planeGroup.add(strutL);
            const strutR = new THREE.Mesh(strutGeo, paintMat);
            strutR.position.set(-4, 1.0, -2.5); strutR.rotation.z = 0.8; planeGroup.add(strutR);

            // --- D. TAIL ---
            const hStab = new THREE.Mesh(new THREE.BoxGeometry(10, 0.3, 3), paintMat);
            hStab.position.set(0, 1.5, 7.5); hStab.castShadow = true; planeGroup.add(hStab);

            // --- E. LANDING GEAR ---
            const gearL = new THREE.Mesh(new THREE.BoxGeometry(0.5, 3, 0.15), chromeMat);
            gearL.position.set(2.5, -1.0, -2.0); gearL.rotation.z = -0.4; planeGroup.add(gearL);
            const pantL = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.0, 1.5), paintMat);
            pantL.position.set(3.8, -2.2, -2.0); planeGroup.add(pantL);
            
            const gearR = new THREE.Mesh(new THREE.BoxGeometry(0.5, 3, 0.15), chromeMat);
            gearR.position.set(-2.5, -1.0, -2.0); gearR.rotation.z = 0.4; planeGroup.add(gearR);
            const pantR = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.0, 1.5), paintMat);
            pantR.position.set(-3.8, -2.2, -2.0); planeGroup.add(pantR);

            const nStrut = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 2.0), chromeMat);
            nStrut.position.set(0, -0.5, -6.0); planeGroup.add(nStrut);
            const nPant = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.0, 1.5), paintMat);
            nPant.position.set(0, -1.8, -6.0); planeGroup.add(nPant);

            // --- F. PROPELLER ---
            propeller = new THREE.Group();
            propeller.position.set(0, 1.0, -8.1); 
            const spinner = new THREE.Mesh(new THREE.ConeGeometry(0.6, 1.2, 16).rotateX(-Math.PI/2), chromeMat);
            propeller.add(spinner);
            const blades = new THREE.Mesh(new THREE.BoxGeometry(7.6, 0.3, 0.15), propMat);
            propeller.add(blades);
            planeGroup.add(propeller);

            // --- G. INTERIOR ---
            const dashGroup = new THREE.Group();
            dashGroup.position.set(0, 1.6, -3.8); 
            planeGroup.add(dashGroup);

            const panel = new THREE.Mesh(new THREE.BoxGeometry(2.3, 0.8, 0.2), dashMat);
            dashGroup.add(panel);
            const shield = new THREE.Mesh(new THREE.BoxGeometry(2.35, 0.1, 0.5), blackMat);
            shield.position.set(0, 0.45, 0.1); dashGroup.add(shield);

            // Gauges
            const gaugeGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.05, 16).rotateX(Math.PI/2);
            const gaugeBlack = new THREE.MeshBasicMaterial({ color: 0x000000 });
            for(let i=0; i<3; i++) { 
                const g = new THREE.Mesh(gaugeGeo, gaugeBlack);
                g.position.set((i-1)*0.55, 0.15, 0.12); dashGroup.add(g);
                const g2 = new THREE.Mesh(gaugeGeo, gaugeBlack);
                g2.position.set((i-1)*0.55, -0.25, 0.12); dashGroup.add(g2);
            }

            // Seats
            const seatGeo = new THREE.BoxGeometry(1.0, 0.5, 1.2);
            const seatBackGeo = new THREE.BoxGeometry(1.0, 1.5, 0.3);
            const seatL = new THREE.Group();
            seatL.position.set(0.6, 0.5, -2.0); 
            const sBase = new THREE.Mesh(seatGeo, interiorMat);
            const sBack = new THREE.Mesh(seatBackGeo, interiorMat);
            sBack.position.set(0, 0.8, 0.4);
            seatL.add(sBase); seatL.add(sBack);
            planeGroup.add(seatL);
            const seatR = seatL.clone();
            seatR.position.set(-0.6, 0.5, -2.0);
            planeGroup.add(seatR);

            // --- H. YOKE ---
            yokeMount = new THREE.Group();
            yokeMount.position.set(0.6, 1.5, -3.8); 
            planeGroup.add(yokeMount);

            const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 1.2).rotateX(Math.PI/2), chromeMat);
            shaft.position.z = 0.6; yokeMount.add(shaft);

            yokeWheel = new THREE.Group();
            yokeWheel.position.z = 1.2; 
            yokeMount.add(yokeWheel);
            yokeWheel.add(new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.15, 0.1), blackMat));
            const hL = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.5).rotateZ(Math.PI/2), blackMat);
            hL.position.set(-0.25, 0, 0); yokeWheel.add(hL);
            const hR = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.5).rotateZ(Math.PI/2), blackMat);
            hR.position.set(0.25, 0, 0); yokeWheel.add(hR);

            // --- I. CAMERA RIG ---
            firstPersonRig = new THREE.Object3D();
            firstPersonRig.position.set(0.6, 2.0, -1.8); 
            planeGroup.add(firstPersonRig);

            return planeGroup;
        }

        const airplane = createCessna();
        scene.add(airplane);

        // --- 4. WORLD ---
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(20000, 20000), new THREE.MeshStandardMaterial({ color: 0x579e3e }));
        floor.rotation.x = -Math.PI / 2; floor.position.y = -50; floor.receiveShadow = true; scene.add(floor);
        const runway = new THREE.Mesh(new THREE.PlaneGeometry(800, 20000), new THREE.MeshStandardMaterial({ color: 0x444444 }));
        runway.rotation.x = -Math.PI / 2; runway.position.y = -49.8; runway.receiveShadow = true; scene.add(runway);

        // --- 5. LOGIC ---
        const keys = { ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false };
        let speed = 0, throttle = 0, rotVel = { x: 0, y: 0, z: 0 }; 
        let isLanded = true, cameraMode = 0; 
        
        // TUNING
        const MAX_SPEED = 2.0; 
        const GRAVITY = 0.35; 
        const LIFT_FACTOR = 0.35;
        const ROT_ACCEL = 0.0012; 
        const FRICTION = 0.98;
        
        const uiThrottle = document.getElementById('throttle-ui');
        const uiSpeed = document.getElementById('speed-ui');
        const uiAlt = document.getElementById('alt-ui');
        const msgOverlay = document.getElementById('msg-overlay');

        window.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.code)) keys[e.code] = true; 
            if (e.key === "ArrowUp") keys.ArrowUp = true;
            if (e.key === "ArrowDown") keys.ArrowDown = true;
            if (e.key === "ArrowLeft") keys.ArrowLeft = true;
            if (e.key === "ArrowRight") keys.ArrowRight = true;
            if (e.code === 'KeyR') resetGame();
            if (e.key.toLowerCase() === 'c') cameraMode = (cameraMode + 1) % 2;
            if (e.key === '0') throttle = 0.0;
            if (e.key === 'q') throttle = 1.0;
            if (e.key >= '1' && e.key <= '9') throttle = parseInt(e.key) / 10;
        });

        window.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.code)) keys[e.code] = false;
            if (e.key === "ArrowUp") keys.ArrowUp = false;
            if (e.key === "ArrowDown") keys.ArrowDown = false;
            if (e.key === "ArrowLeft") keys.ArrowLeft = false;
            if (e.key === "ArrowRight") keys.ArrowRight = false;
        });

        function resetGame() {
            // Start height accounts for gear
            airplane.position.set(0, -42, 0); 
            airplane.rotation.set(0, 0, 0);
            speed = 0; throttle = 0; rotVel = { x:0, y:0, z:0 };
            isLanded = true;
            msgOverlay.style.display = 'none';
        }

        function updatePhysics() {
            let targetSpeed = throttle * MAX_SPEED;
            speed = THREE.MathUtils.lerp(speed, targetSpeed, 0.005);

            // YOKE ANIMATION
            let targetRoll = 0;
            if (keys.ArrowLeft) targetRoll = 1.0; if (keys.ArrowRight) targetRoll = -1.0;
            yokeWheel.rotation.z = THREE.MathUtils.lerp(yokeWheel.rotation.z, targetRoll, 0.1);
            let targetPitch = 0.5;
            if (keys.ArrowUp) targetPitch = 0.7; if (keys.ArrowDown) targetPitch = 0.3;
            yokeMount.position.z = THREE.MathUtils.lerp(yokeMount.position.z, targetPitch, 0.1);

            // FLIGHT CONTROLS
            const authority = Math.min(speed, 1.0); 
            if (!isLanded || speed > 0.1) {
                if (keys.ArrowUp) rotVel.x -= ROT_ACCEL * authority; 
                if (keys.ArrowDown) rotVel.x += ROT_ACCEL * authority;
                if (keys.ArrowLeft) { rotVel.z += ROT_ACCEL * authority; rotVel.y += (ROT_ACCEL * 0.4) * authority; }
                if (keys.ArrowRight) { rotVel.z -= ROT_ACCEL * authority; rotVel.y -= (ROT_ACCEL * 0.4) * authority; }
            }

            airplane.rotateX(rotVel.x); airplane.rotateY(rotVel.y); airplane.rotateZ(rotVel.z);
            rotVel.x *= FRICTION; rotVel.y *= FRICTION; rotVel.z *= FRICTION;

            airplane.translateZ(-speed);

            // LIFT & GRAVITY
            let liftForce = speed * LIFT_FACTOR * 1.5; 
            liftForce -= rotVel.x * 30; 

            if (!isLanded) {
                airplane.position.y -= GRAVITY;
                airplane.position.y += liftForce;
            } else {
                if (liftForce > GRAVITY) {
                    isLanded = false; 
                    msgOverlay.style.display = 'none';
                    airplane.position.y += (liftForce - GRAVITY);
                }
            }

            // GROUND COLLISION (NO CRASH)
            const altitude = airplane.position.y + 42; 
            if (altitude <= 0) { 
                // We hit ground
                airplane.position.y = -42;
                isLanded = true;

                // Simple "Bounce" or "Slide" logic
                // Reset heavy banks instantly so you don't roll over
                if(Math.abs(airplane.rotation.z) > 0.5) {
                    airplane.rotation.z *= 0.8; 
                }
                // Reset Pitch if nose down to prevent digging
                if(airplane.rotation.x > 0.1) {
                    airplane.rotation.x = 0;
                }

                // Check for smooth landing
                const pitch = airplane.rotation.x % (Math.PI*2);
                if (speed < 0.8 && Math.abs(pitch) < 0.1) {
                    msgOverlay.style.display = 'block'; // "Perfect Landing"
                } else {
                    msgOverlay.style.display = 'none';
                }
            } else {
                msgOverlay.style.display = 'none';
            }

            if(propeller) propeller.rotation.z += speed * 2;
            
            uiThrottle.innerText = Math.floor(throttle * 100);
            uiSpeed.innerText = Math.floor(speed * 60); 
            uiAlt.innerText = Math.floor(Math.max(0, altitude * 5));
        }

        const dummyVec = new THREE.Vector3();
        const dummyQuat = new THREE.Quaternion();

        function updateCamera() {
            if (cameraMode === 0) {
                // CHASE
                const offset = new THREE.Vector3(0, 15, 60); 
                const targetPos = offset.applyMatrix4(airplane.matrixWorld);
                camera.position.lerp(targetPos, 0.1);
                const lookOffset = new THREE.Vector3(0, 0, -50);
                const lookTarget = lookOffset.applyMatrix4(airplane.matrixWorld);
                camera.lookAt(lookTarget);
            } else {
                // PILOT
                firstPersonRig.getWorldPosition(dummyVec);
                firstPersonRig.getWorldQuaternion(dummyQuat);
                camera.position.copy(dummyVec);
                camera.quaternion.copy(dummyQuat);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            updateCamera();
            dirLight.position.x = airplane.position.x + 100;
            dirLight.position.z = airplane.position.z + 100;
            dirLight.target = airplane;
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        resetGame();
        animate();
    </script>
</body>
</html>
