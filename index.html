<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>3D Flight Demo</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Courier New', Courier, monospace; touch-action: none; }
    #canvas-container { width: 100vw; height: 100vh; display: block; }

    /* HUD */
    #hud {
      position: absolute; top: 20px; left: 20px;
      color: #0f0; background: rgba(0, 0, 0, 0.5);
      padding: 15px; border-radius: 8px;
      pointer-events: none; user-select: none;
      border: 2px solid #0f0; box-shadow: 0 0 10px #0f0;
      z-index: 10; min-width: 150px;
    }
    .hud-row { margin-bottom: 5px; font-weight: bold; display: flex; justify-content: space-between; }
    .hud-label { margin-right: 10px; }
    .warning { color: red; animation: blink 0.5s infinite; display: none; text-align: center; margin-top: 5px; }
    @keyframes blink { 50% { opacity: 0; } }

    /* Help */
    #controls-help {
      position: absolute; top: 20px; right: 20px;
      text-align: right; color: white;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px; border-radius: 5px;
      font-family: sans-serif; font-size: 12px;
      pointer-events: none; z-index: 10; display: none;
    }
    @media (min-width: 800px) { #controls-help { display: block; } }

    /* Overlays */
    #overlay-msg, #start-screen {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      color: white; font-family: sans-serif; font-weight: bold;
      background: rgba(0,0,0,0.8);
      padding: 30px; border-radius: 10px; text-align: center;
      z-index: 20; cursor: pointer; border: 2px solid white;
    }
    #overlay-msg { display: none; font-size: 24px; }
    #start-screen { display: flex; flex-direction: column; align-items: center; gap: 10px; }
    h1 { margin: 0 0 10px 0; font-size: 28px; text-transform: uppercase; color: #87CEEB; }
    p { margin: 5px 0; color: #ddd; }
    .key { background: #333; padding: 2px 6px; border-radius: 4px; border: 1px solid #666; font-family: monospace; }
    .btn-start {
      margin-top: 20px; padding: 10px 30px;
      font-size: 20px; background: #2196F3; color: white;
      border: none; border-radius: 5px; cursor: pointer;
    }
    .btn-start:hover { background: #1976D2; }

    /* Touch UI */
    .touch-control { position: absolute; z-index: 15; user-select: none; touch-action: none; }

    #throttle-container {
      bottom: 40px; left: 40px;
      width: 40px; height: 200px;
      background: rgba(0, 0, 0, 0.3);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 20px;
    }
    #throttle-fill {
      position: absolute; bottom: 0; left: 0;
      width: 100%; height: 0%;
      background: #ffcc00; border-radius: 18px;
      pointer-events: none;
    }
    #throttle-label {
      position: absolute; top: -25px; left: 0; width: 100%;
      text-align: center; color: white; font-weight: bold; font-size: 12px;
      text-shadow: 1px 1px 0 #000;
    }

    #reset-btn {
      bottom: 20px; right: 20px;
      width: 40px; height: 40px;
      background: rgba(255, 0, 0, 0.5);
      border: 2px solid white; border-radius: 8px; color: white;
      display: flex; align-items: center; justify-content: center;
      font-weight: bold; cursor: pointer;
    }
  </style>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
</head>
<body>

<div id="hud">
  <div class="hud-row"><span class="hud-label">SPD:</span> <span id="speed-display">0</span> kts</div>
  <div class="hud-row"><span class="hud-label">ALT:</span> <span id="alt-display">0</span> ft</div>
  <div class="hud-row"><span class="hud-label">HDG:</span> <span id="hdg-display">0</span>°</div>
  <div class="hud-row"><span class="hud-label">THR:</span> <span id="thr-display">0</span>%</div>
  <div class="hud-row"><span class="hud-label">VSI:</span> <span id="vsi-display">0</span> fpm</div>
  <div class="hud-row"><span class="hud-label">AOA:</span> <span id="aoa-display">0</span>°</div>
  <div class="hud-row"><span class="hud-label">G:</span> <span id="g-display">1.0</span></div>
  <div class="hud-row"><span class="hud-label">GEAR:</span> <span id="gear-display">DN</span></div>
  <div id="brake-warning" class="warning">BRAKE</div>
  <div id="stall-warning" class="warning">STALL</div>
</div>

<div id="controls-help">
  <b>Controls:</b><br>
  <span class="key">W</span> / <span class="key">S</span> - Throttle (Hold W)<br>
  <span class="key">A</span> - Afterburner (Hold)<br>
  <span class="key">Space</span> - Air Brake / Wheel Brakes<br>
  <span class="key">G</span> - Toggle Landing Gear<br>
  Arrows - Pitch/Roll & Steering<br>
  <span class="key">Q</span> / <span class="key">E</span> - Rudder<br>
  <i>Hold Down Arrow at 110kts to Fly</i>
</div>

<div id="start-screen" onclick="startGame()">
  <h1>3D Flight Demo</h1>
  <p>Click to Start</p>
  <p>Use <span class="key">W</span> to Throttle Up</p>
  <p>Hold <span class="key">A</span> for Afterburner</p>
  <p>Hold <span class="key">Space</span> for Air Brake / Brakes</p>
  <p>Use <span class="key">G</span> for Landing Gear</p>
  <p>Use <span class="key">Arrows</span> to Steer/Fly</p>
  <button class="btn-start">START FLIGHT</button>
</div>

<div id="overlay-msg" onclick="resetPlane()">CRASH<br>Tap to Restart</div>

<div id="throttle-container" class="touch-control">
  <div id="throttle-label">THR</div>
  <div id="throttle-fill"></div>
</div>

<div id="reset-btn" class="touch-control" onclick="resetPlane()">R</div>

<div id="canvas-container"></div>

<script>
/* =========================
   Globals
========================= */
let scene, camera, renderer, clock;
let plane;
let gameActive = false;

let PHYSICS = {};
let sim = {};

let stallAudio = null;

const VISUALS = {
  colors: {
    fuselage: 0xb0b7c0,
    glass: 0x112244,
    tire: 0x111111,
    exhaust: 0x444444
  }
};

let input = { pitch: 0, roll: 0, yaw: 0, throttle: 0 };
let keys = {};

/* =========================
   World & Terrain Settings
========================= */
const WORLD = {
  size: 40000,
  segments: 120,      // lower = faster
  runwayY: 0.2,
  groundY: -0.05
};

// runway rectangle (flat) + a buffer zone where terrain is smoothly faded down
const RUNWAY = {
  halfW: 80,
  halfL: 2100,
  fadeW: 220,   // how far out from runway edge to fade terrain down
  fadeL: 500
};

function smoothstep(edge0, edge1, x) {
  const t = THREE.MathUtils.clamp((x - edge0) / (edge1 - edge0), 0, 1);
  return t * t * (3 - 2 * t);
}

function runwayMask(x, z) {
  // 0 inside runway, smoothly goes to 1 outside runway+fade.
  const ax = Math.abs(x);
  const az = Math.abs(z);

  const dx = ax - RUNWAY.halfW;
  const dz = az - RUNWAY.halfL;

  // if inside runway bounds, kill terrain completely
  if (dx <= 0 && dz <= 0) return 0;

  // fade based on how far outside the runway edges you are
  const fx = smoothstep(0, RUNWAY.fadeW, Math.max(0, dx));
  const fz = smoothstep(0, RUNWAY.fadeL, Math.max(0, dz));

  // combine fades (either direction near runway reduces terrain)
  return Math.max(fx, fz);
}

function isOnRunwayXZ(x, z) {
  return (Math.abs(x) < RUNWAY.halfW && Math.abs(z) < RUNWAY.halfL);
}

// Height above "base ground" (no groundY offset). Tuned for “higher” not “wider”.
function terrainHeightRaw(x, z) {
  const size = WORLD.size;
  const nx = x / size;
  const nz = z / size;

  // same general "wavelength" as your original, but taller + a 2nd octave
  const big   = Math.sin(nx * Math.PI * 4.0) * Math.cos(nz * Math.PI * 3.0) * 85;
  const mid   = Math.sin(nx * 2.3) * Math.sin(nz * 2.8) * 35;
  const small = Math.sin(nx * 10.0) * Math.cos(nz * 9.0) * 10;

  const raw = big + mid + small;

  // keep terrain UNDER the runway by fading it down near runway edges
  const m = runwayMask(x, z);
  return raw * m;
}

function getGroundHeight(x, z) {
  // runway stays perfectly flat
  if (isOnRunwayXZ(x, z)) return WORLD.runwayY;

  // terrain world height
  return WORLD.groundY + terrainHeightRaw(x, z);
}

/* =========================
   Start / Init
========================= */
function startGame() {
  document.getElementById('start-screen').style.display = 'none';
  gameActive = true;
  resetPlane();

  if (!stallAudio) {
    stallAudio = new Audio("stall_warning.mp3");
    stallAudio.loop = true;
    stallAudio.volume = 0.8;
  }
}

function init() {
  PHYSICS = {
    mass: 3500,
    gravity: 9.81,
    airDensity: 1.225,
    wingArea: 24.0,

    dragCoeffZero: 0.020,
    inducedDragFactor: 0.06,
    liftSlope: 7.5,
    maxLiftCoeff: 1.6,
    stallAngle: 0.45,
    wingIncidence: 0.02,

    maxThrust: 70000,

    momentInertia: new THREE.Vector3(12000, 15000, 12000),

    wheelFriction: 0.09,
    suspensionStiffness: 65000,
    suspensionDamping: 4000
  };

  sim = {
    pos: new THREE.Vector3(0, WORLD.runwayY + 1.35, 1200),
    vel: new THREE.Vector3(0, 0, 0),
    quat: new THREE.Quaternion(),
    angularVel: new THREE.Vector3(0, 0, 0),

    crashed: false,
    stalled: false,
    onGround: true,
    gearDown: true,

    afterburner: false,
    airBrake: false,

    alpha: 0,
    gLoad: 1.0
  };

  const container = document.getElementById('canvas-container');
  clock = new THREE.Clock();

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87CEEB);
  scene.fog = new THREE.Fog(0xbfd5ff, 3500, 20000);

  renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.5)); // less lag
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.05;
  container.appendChild(renderer.domElement);

  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 30000);

  // Sky
  const skyGeo = new THREE.SphereGeometry(12000, 32, 15);
  const skyMat = new THREE.ShaderMaterial({
    side: THREE.BackSide,
    uniforms: {
      topColor: { value: new THREE.Color(0x6fb6ff) },
      bottomColor: { value: new THREE.Color(0xf5fbff) },
      offset: { value: 33 },
      exponent: { value: 0.6 }
    },
    vertexShader: `
      varying vec3 vWorldPosition;
      void main() {
        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
        vWorldPosition = worldPosition.xyz;
        gl_Position = projectionMatrix * viewMatrix * worldPosition;
      }
    `,
    fragmentShader: `
      varying vec3 vWorldPosition;
      uniform vec3 topColor;
      uniform vec3 bottomColor;
      uniform float offset;
      uniform float exponent;
      void main() {
        float h = normalize(vWorldPosition + vec3(0.0, offset, 0.0)).y;
        float f = max(pow(max(h, 0.0), exponent), 0.0);
        vec3 col = mix(bottomColor, topColor, f);
        gl_FragColor = vec4(col, 1.0);
      }
    `
  });
  scene.add(new THREE.Mesh(skyGeo, skyMat));

  // Lights (lower shadow res = faster)
  scene.add(new THREE.AmbientLight(0xffffff, 0.35));
  scene.add(new THREE.HemisphereLight(0xe6f1ff, 0x1e2a16, 0.35));

  const sun = new THREE.DirectionalLight(0xffffff, 1.15);
  sun.position.set(300, 600, 200);
  sun.castShadow = true;
  sun.shadow.mapSize.width = 2048;
  sun.shadow.mapSize.height = 2048;
  sun.shadow.camera.near = 10;
  sun.shadow.camera.far = 6000;
  sun.shadow.camera.left = -1200;
  sun.shadow.camera.right = 1200;
  sun.shadow.camera.top = 1200;
  sun.shadow.camera.bottom = -1200;
  scene.add(sun);

  createWorld();

  plane = createJetMesh();
  scene.add(plane);

  window.addEventListener('resize', onResize);
  document.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (e.code === 'KeyG') toggleGear();
  });
  document.addEventListener('keyup', e => keys[e.code] = false);

  animate();
}

function toggleGear() {
  sim.gearDown = !sim.gearDown;
  if (plane && plane.userData.gearGroup) plane.userData.gearGroup.visible = sim.gearDown;
}

/* =========================
   Inputs
========================= */
function updateInputs() {
  if (!gameActive) return;

  let kYaw = (keys['KeyQ'] ? 1 : 0) - (keys['KeyE'] ? 1 : 0);

  if (keys['KeyW']) input.throttle += 0.015;
  if (keys['KeyS']) input.throttle -= 0.02;
  input.throttle = THREE.MathUtils.clamp(input.throttle, 0, 1);

  sim.afterburner = keys['KeyA'];
  sim.airBrake    = keys['Space'];

  let keyPitchCmd = 0;
  if (keys['ArrowDown']) keyPitchCmd = 1;
  if (keys['ArrowUp']) keyPitchCmd = -1;

  let keyRollCmd = 0;
  if (keys['ArrowRight']) keyRollCmd = 1;
  if (keys['ArrowLeft']) keyRollCmd = -1;

  // ground steering assist
  if (sim.onGround) {
    if (kYaw === 0 && Math.abs(keyRollCmd) > 0) kYaw = keyRollCmd * 0.5;
  }

  input.pitch = THREE.MathUtils.clamp(keyPitchCmd, -1, 1);
  input.roll  = THREE.MathUtils.clamp(keyRollCmd, -1, 1);
  input.yaw   = THREE.MathUtils.clamp(kYaw, -1, 1);
}

/* =========================
   Physics
========================= */
function updatePhysics(dt) {
  if (sim.crashed) return;

  updateInputs();

  const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(sim.quat);
  const up      = new THREE.Vector3(0, 1, 0).applyQuaternion(sim.quat);
  const right   = new THREE.Vector3(1, 0, 0).applyQuaternion(sim.quat);

  const speed = sim.vel.length();
  const localVel = sim.vel.clone().applyQuaternion(sim.quat.clone().invert());

  // AOA
  let alpha = PHYSICS.wingIncidence;
  if (speed > 1) alpha += Math.atan2(-localVel.y, -localVel.z);
  sim.alpha = alpha;
  sim.stalled = Math.abs(alpha) > PHYSICS.stallAngle;

  // Aero
  const q = 0.5 * PHYSICS.airDensity * (speed * speed);

  let cl = PHYSICS.liftSlope * alpha;
  cl = THREE.MathUtils.clamp(cl, -PHYSICS.maxLiftCoeff, PHYSICS.maxLiftCoeff);

  let groundEffect = 1.0;
  if (sim.pos.y < 5.0) groundEffect = 1.2;

  const liftForce = up.clone().multiplyScalar(q * PHYSICS.wingArea * cl * groundEffect);

  const cd = PHYSICS.dragCoeffZero + (PHYSICS.inducedDragFactor * cl * cl);
  let dragMag = q * PHYSICS.wingArea * cd;
  if (sim.airBrake) dragMag *= 15.0;
  const dragForce = (speed > 0.1) ? sim.vel.clone().normalize().negate().multiplyScalar(dragMag) : new THREE.Vector3();

  // Thrust
  let currentThrottle = input.throttle;
  let abBoost = 1.0;

  if (sim.airBrake) {
    currentThrottle = 0;
  } else if (sim.afterburner) {
    currentThrottle = 1.1;
    abBoost = 2.0;
  }

  const thrustFactor = Math.max(0.4, 1 - (speed / 350));
  const thrustForce = forward.clone().multiplyScalar(currentThrottle * PHYSICS.maxThrust * thrustFactor * abBoost);

  // Visuals: afterburners + airbrakes
  if (plane) {
    if (plane.userData.afterburners) {
      const speedFactor = THREE.MathUtils.clamp(speed / 250, 0, 1.2);
      plane.userData.afterburners.forEach((ab, idx) => {
        ab.visible = sim.afterburner;
        if (!sim.afterburner) return;
        const flicker = 0.8 + Math.random() * 0.4;
        const base = (idx === 0) ? 1.0 : 0.6;
        const s = base * (1.0 + 0.6 * speedFactor) * flicker;
        if (idx === 0) ab.scale.set(s, s, s * 1.8);
        else ab.scale.set(s * 0.6, s * 0.6, s * 1.4);
      });
    }
    const brakeSpeed = 5.0 * dt;
    const targetRot = sim.airBrake ? 0.9 : 0;
    if (plane.userData.airBrakeL) plane.userData.airBrakeL.rotation.y += (targetRot - plane.userData.airBrakeL.rotation.y) * brakeSpeed;
    if (plane.userData.airBrakeR) plane.userData.airBrakeR.rotation.y += (-targetRot - plane.userData.airBrakeR.rotation.y) * brakeSpeed;
  }

  const gravityForce = new THREE.Vector3(0, -PHYSICS.gravity * PHYSICS.mass, 0);

  const totalForce = new THREE.Vector3()
    .add(liftForce)
    .add(dragForce)
    .add(thrustForce)
    .add(gravityForce);

  /* ---- Ground contact (runway OR hills) ----
     - Gear DOWN: never crash from touching hills; you can roll on them.
     - Gear UP: belly strike => crash (anywhere).
  */
  const gearHeight  = 1.35;
  const bellyHeight = 0.5;

  const groundH = getGroundHeight(sim.pos.x, sim.pos.z);
  const wasOnGround = sim.onGround;

  let suspensionTorque = 0;

  if (sim.gearDown) {
    const contactY = groundH + gearHeight;
    sim.onGround = (sim.pos.y <= contactY);

    if (sim.onGround) {
      if (sim.pos.y < contactY) sim.pos.y = contactY;

      // touchdown dust (anywhere)
      if (!wasOnGround && plane && plane.userData.dust) {
        const touchdownSpeed = sim.vel.length();
        plane.userData.dust.material.opacity = THREE.MathUtils.clamp(touchdownSpeed / 60, 0.2, 0.8);

        const trackDirLocal = sim.vel.clone();
        trackDirLocal.y = 0;
        trackDirLocal.applyQuaternion(sim.quat.clone().invert());
        if (trackDirLocal.lengthSq() > 0.1) {
          trackDirLocal.normalize();
          plane.userData.dust.rotation.y = Math.atan2(trackDirLocal.x, trackDirLocal.z);
        }
      }

      // prevent sinking
      if (sim.vel.y < 0) {
        sim.vel.y = 0;
        if (totalForce.y < 0) totalForce.y = 0;
      }

      // friction / braking
      const normalForce = Math.max(0, PHYSICS.mass * PHYSICS.gravity - liftForce.y);
      const frictionMag = normalForce * PHYSICS.wheelFriction;

      if (speed > 0.1) {
        totalForce.add(sim.vel.clone().normalize().negate().multiplyScalar(frictionMag));
      }

      if (sim.airBrake && speed > 0.5) {
        totalForce.add(sim.vel.clone().normalize().negate().multiplyScalar(normalForce * 0.6));
      }

      // side friction
      const sideVel = sim.vel.dot(right);
      totalForce.add(right.clone().multiplyScalar(-sideVel * 2.0 * PHYSICS.mass * dt));

      // steering
      if (speed > 1) sim.angularVel.y += input.yaw * 0.8 * dt;

      // suspension pitch spring
      const euler = new THREE.Euler().setFromQuaternion(sim.quat, 'YXZ');
      if (euler.x < 0) {
        suspensionTorque += -euler.x * PHYSICS.suspensionStiffness;
        suspensionTorque -= sim.angularVel.x * PHYSICS.suspensionDamping;
      } else if (euler.x > 0.3) {
        suspensionTorque += -(euler.x - 0.3) * PHYSICS.suspensionStiffness;
      }
    }
  } else {
    // gear UP: belly strike crashes anywhere
    sim.onGround = false;
    if (sim.pos.y < groundH + bellyHeight) {
      sim.crashed = true;
      document.getElementById('overlay-msg').innerHTML = "CRASH<br>Click to Reset";
      document.getElementById('overlay-msg').style.display = 'block';
      return;
    }
  }

  // Moments / torque
  const controlScale = (q * PHYSICS.wingArea) / 2500;

  let yawStability = 0;
  if (speed > 50) yawStability = -localVel.x * 6.25 * controlScale;

  const stabilityPitch = -alpha * 40000;
  const controlPitch = input.pitch * 45000;

  const effectiveQ = Math.max(q, 100);
  let pitchTorque = (stabilityPitch + controlPitch) * (effectiveQ / 2000);
  pitchTorque += suspensionTorque;

  const controlRoll = -input.roll * 1750 * controlScale;
  const controlYaw  = (input.yaw * 2000 * controlScale) + yawStability;

  const torqueLocal = new THREE.Vector3(pitchTorque, controlYaw, controlRoll);

  // G-load
  const accelNoDt = totalForce.clone().divideScalar(PHYSICS.mass);
  const properAccel = accelNoDt.clone().sub(new THREE.Vector3(0, -PHYSICS.gravity, 0));
  sim.gLoad = THREE.MathUtils.clamp(properAccel.dot(up) / PHYSICS.gravity, -3, 9);

  // Integrate linear
  sim.vel.add(totalForce.divideScalar(PHYSICS.mass).multiplyScalar(dt));
  sim.pos.add(sim.vel.clone().multiplyScalar(dt));

  // Integrate angular
  const angAccel = new THREE.Vector3(
    torqueLocal.x / PHYSICS.momentInertia.x,
    torqueLocal.y / PHYSICS.momentInertia.y,
    torqueLocal.z / PHYSICS.momentInertia.z
  );

  sim.angularVel.multiplyScalar(1.0 - (2.0 * dt));
  sim.angularVel.add(angAccel.multiplyScalar(dt));

  const rotMag = sim.angularVel.length();
  if (rotMag > 0.0001) {
    const deltaRot = new THREE.Quaternion().setFromAxisAngle(sim.angularVel.clone().normalize(), rotMag * dt);
    sim.quat.multiply(deltaRot).normalize();
  }

  // keep wings mostly level when on ground (anywhere)
  if (sim.onGround) {
    const euler = new THREE.Euler().setFromQuaternion(sim.quat, 'YXZ');
    euler.z *= 0.95;
    sim.quat.setFromEuler(euler);
    sim.angularVel.z *= 0.8;
  }

  // wingtip vapor
  if (plane && plane.userData.vaporL) {
    const aoaStrength = THREE.MathUtils.clamp(Math.abs(sim.alpha) / PHYSICS.stallAngle, 0, 1);
    const speedFactor = THREE.MathUtils.clamp(speed / 120, 0, 1);
    const vaporOpacity = aoaStrength * speedFactor;

    plane.userData.vaporL.material.opacity = vaporOpacity;
    plane.userData.vaporR.material.opacity = vaporOpacity;

    if (speed > 1) {
      const flowLocal = sim.vel.clone().applyQuaternion(sim.quat.clone().invert()).normalize().negate();
      const vaporQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), flowLocal);
      plane.userData.vaporL.quaternion.copy(vaporQuat);
      plane.userData.vaporR.quaternion.copy(vaporQuat);
    }
  }

  // dust fade
  if (plane && plane.userData.dust) {
    plane.userData.dust.material.opacity *= 0.75;
    plane.userData.dust.material.opacity -= 0.6 * dt;
    if (plane.userData.dust.material.opacity < 0) plane.userData.dust.material.opacity = 0;
  }

  // Sync mesh
  plane.position.copy(sim.pos);
  plane.quaternion.copy(sim.quat);
}

/* =========================
   HUD + Camera + Reset
========================= */
function updateHUD() {
  if (!sim.vel) return;

  const spd = Math.round(sim.vel.length() * 1.9438);

  // altitude above ground under you (with gear height reference)
  const groundBelow = getGroundHeight(sim.pos.x, sim.pos.z);
  const alt = Math.round((sim.pos.y - (groundBelow + 1.35)) * 3.2808);

  const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(sim.quat);
  let hdg = Math.round(Math.atan2(-fwd.x, -fwd.z) * 180 / Math.PI);
  if (hdg < 0) hdg += 360;

  const vsi = Math.round(sim.vel.y * 60 * 3.2808);
  const aoaDeg = Math.round((sim.alpha || 0) * 57.2958);
  const gLoad = sim.gLoad || 1.0;

  document.getElementById('speed-display').innerText = spd;
  document.getElementById('alt-display').innerText = alt;
  document.getElementById('hdg-display').innerText = hdg;

  let throttleVal = Math.round(input.throttle * 100);
  const thrEl = document.getElementById('thr-display');

  if (sim.airBrake) {
    throttleVal = 0;
    thrEl.style.color = '#fa0';
    thrEl.style.textShadow = 'none';
  } else if (sim.afterburner) {
    throttleVal = 110;
    thrEl.style.color = 'red';
    thrEl.style.textShadow = '0 0 5px red';
  } else {
    thrEl.style.color = '#0f0';
    thrEl.style.textShadow = 'none';
  }
  thrEl.innerText = throttleVal;

  document.getElementById('vsi-display').innerText = vsi;
  document.getElementById('aoa-display').innerText = aoaDeg;
  document.getElementById('g-display').innerText = gLoad.toFixed(1);

  document.getElementById('gear-display').innerText = sim.gearDown ? "DWN" : "UP";
  document.getElementById('gear-display').style.color = sim.gearDown ? "#0f0" : "#fa0";

  document.getElementById('stall-warning').style.display = sim.stalled ? 'block' : 'none';
  document.getElementById('brake-warning').style.display = (sim.airBrake && sim.onGround) ? 'block' : 'none';

  let barHeight = input.throttle * 100;
  let barColor = '#ffcc00';
  if (sim.airBrake) barHeight = 0;
  else if (sim.afterburner) { barHeight = 100; barColor = 'red'; }
  document.getElementById('throttle-fill').style.height = barHeight + '%';
  document.getElementById('throttle-fill').style.backgroundColor = barColor;

  if (stallAudio) {
    if (sim.stalled) {
      if (stallAudio.paused) {
        stallAudio.currentTime = 0;
        stallAudio.play().catch(()=>{});
      }
    } else {
      if (!stallAudio.paused) stallAudio.pause();
    }
  }
}

function updateCamera() {
  if (!sim.pos) return;
  const offset = new THREE.Vector3(0, 6, 28).applyQuaternion(sim.quat);
  const target = sim.pos.clone().add(offset);
  if (target.y < 2) target.y = 2;
  camera.position.lerp(target, 0.1);
  camera.lookAt(sim.pos.clone().add(new THREE.Vector3(0,0,0).applyQuaternion(sim.quat)));
}

function resetPlane() {
  sim.pos.set(0, WORLD.runwayY + 1.35, 1200);
  sim.vel.set(0, 0, 0);
  sim.quat.set(0, 0, 0, 1);
  sim.angularVel.set(0, 0, 0);
  sim.crashed = false;
  sim.stalled = false;
  sim.onGround = true;
  sim.gearDown = true;
  sim.afterburner = false;
  sim.airBrake = false;
  sim.alpha = 0;
  sim.gLoad = 1.0;

  if (plane) {
    if (plane.userData.gearGroup) plane.userData.gearGroup.visible = true;
    if (plane.userData.airBrakeL) plane.userData.airBrakeL.rotation.y = 0;
    if (plane.userData.airBrakeR) plane.userData.airBrakeR.rotation.y = 0;
    if (plane.userData.dust) plane.userData.dust.material.opacity = 0;
  }

  input.throttle = 0;
  input.pitch = 0;
  input.roll = 0;
  input.yaw = 0;

  document.getElementById('throttle-fill').style.height = '0%';
  document.getElementById('overlay-msg').style.display = 'none';
}

/* =========================
   Jet Mesh
========================= */
function createJetMesh() {
  const root = new THREE.Group();

  const matBody = new THREE.MeshStandardMaterial({
    color: VISUALS.colors.fuselage, metalness: 0.7, roughness: 0.28
  });
  const matGlass = new THREE.MeshPhysicalMaterial({
    color: VISUALS.colors.glass,
    metalness: 0.0, roughness: 0.1,
    transparent: true, opacity: 0.5, transmission: 0.7,
    clearcoat: 1.0, clearcoatRoughness: 0.15
  });
  const matExhaust = new THREE.MeshStandardMaterial({
    color: VISUALS.colors.exhaust, metalness: 0.9, roughness: 0.35,
    emissive: 0x111111, emissiveIntensity: 0.4
  });

  const fuse = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.6, 12, 24), matBody);
  fuse.rotation.x = -Math.PI/2; fuse.castShadow = true; root.add(fuse);

  const nose = new THREE.Mesh(new THREE.ConeGeometry(0.6, 3, 24), matBody);
  nose.rotation.x = -Math.PI/2; nose.position.z = -7.5; nose.castShadow = true; root.add(nose);

  const cockpit = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 1.5, 8, 16), matGlass);
  cockpit.rotation.x = -Math.PI/2; cockpit.position.set(0, 0.8, -3); cockpit.castShadow = true; root.add(cockpit);

  // Air brakes
  const airBrakeGeo = new THREE.BoxGeometry(0.12, 0.6, 1.5);
  airBrakeGeo.translate(0, 0, 0.75);

  const brakeL = new THREE.Mesh(airBrakeGeo, matBody);
  brakeL.position.set(0.9, 0, 4.2); brakeL.castShadow = true; root.add(brakeL);

  const brakeR = new THREE.Mesh(airBrakeGeo, matBody);
  brakeR.position.set(-0.9, 0, 4.2); brakeR.castShadow = true; root.add(brakeR);

  root.userData.airBrakeL = brakeL;
  root.userData.airBrakeR = brakeR;

  // Wings
  const wingShape = new THREE.Shape();
  const ww = 6, hh = 4, rr = 0.6;
  wingShape.absarc(ww/2 - rr, hh/2 - rr, rr, 0, Math.PI / 2, false);
  wingShape.absarc(-ww/2 + rr, hh/2 - rr, rr, Math.PI / 2, Math.PI, false);
  wingShape.absarc(-ww/2 + rr, -hh/2 + rr, rr, Math.PI, Math.PI * 1.5, false);
  wingShape.absarc(ww/2 - rr, -hh/2 + rr, rr, Math.PI * 1.5, Math.PI * 2, false);

  const wingGeo = new THREE.ExtrudeGeometry(wingShape, {
    depth: 0.09, bevelEnabled: true, bevelThickness: 0.03, bevelSize: 0.06, bevelSegments: 4
  });
  wingGeo.center(); wingGeo.rotateX(Math.PI / 2);

  const wingL = new THREE.Mesh(wingGeo, matBody);
  wingL.position.set(2.5, 0, 1); wingL.rotation.y = -0.5; wingL.castShadow = true; root.add(wingL);

  const wingR = new THREE.Mesh(wingGeo, matBody);
  wingR.position.set(-2.5, 0, 1); wingR.rotation.y = 0.5; wingR.castShadow = true; root.add(wingR);

  // Exhaust
  const exMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.6, 0.8, 20), matExhaust);
  exMesh.rotation.x = -Math.PI/2; exMesh.position.set(0, 0, 6.2); exMesh.castShadow = true; root.add(exMesh);

  // Afterburners
  const outerGeo = new THREE.ConeGeometry(0.5, 4.0, 16, 1, true);
  outerGeo.translate(0, 2.0, 0); outerGeo.rotateX(Math.PI / 2);

  const flameOuter = new THREE.Mesh(outerGeo, new THREE.MeshBasicMaterial({
    color: 0xffaa33, transparent: true, opacity: 0.55,
    blending: THREE.AdditiveBlending, depthWrite: false
  }));
  flameOuter.position.set(0, 0, 6.6); flameOuter.visible = false; root.add(flameOuter);

  const innerGeo = new THREE.ConeGeometry(0.3, 3.0, 16, 1, true);
  innerGeo.translate(0, 1.5, 0); innerGeo.rotateX(Math.PI / 2);

  const flameInner = new THREE.Mesh(innerGeo, new THREE.MeshBasicMaterial({
    color: 0x66c9ff, transparent: true, opacity: 0.8,
    blending: THREE.AdditiveBlending, depthWrite: false
  }));
  flameInner.position.set(0, 0, 6.7); flameInner.visible = false; root.add(flameInner);

  root.userData.afterburners = [flameOuter, flameInner];

  // Tail
  const tail = new THREE.Mesh(new THREE.BoxGeometry(0.12, 3.1, 3), matBody);
  tail.position.set(0, 1.5, 5.1); tail.rotation.x = 0.55; tail.castShadow = true; root.add(tail);

  const hStab = new THREE.Mesh(new THREE.BoxGeometry(3.7, 0.12, 2.1), matBody);
  hStab.position.set(0, 0.25, 5.6); hStab.rotation.x = -0.1; hStab.castShadow = true; root.add(hStab);

  // Gear
  const gearGroup = new THREE.Group();
  root.add(gearGroup);
  root.userData.gearGroup = gearGroup;

  const tireGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.25, 16);
  tireGeo.rotateZ(Math.PI/2);
  const tireMat = new THREE.MeshStandardMaterial({ color: VISUALS.colors.tire, roughness: 0.9, metalness: 0.0 });

  const noseWheel = new THREE.Mesh(tireGeo, tireMat);
  noseWheel.position.set(0, -1.2, -5); noseWheel.castShadow = true; gearGroup.add(noseWheel);

  const mainWheelL = new THREE.Mesh(tireGeo, tireMat);
  mainWheelL.position.set(1.4, -1.2, 1); mainWheelL.castShadow = true; gearGroup.add(mainWheelL);

  const mainWheelR = new THREE.Mesh(tireGeo, tireMat);
  mainWheelR.position.set(-1.4, -1.2, 1); mainWheelR.castShadow = true; gearGroup.add(mainWheelR);

  // Vapors
  const vaporMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.0, depthWrite: false });
  const vaporGeo = new THREE.PlaneGeometry(2, 0.4);

  const vaporL = new THREE.Mesh(vaporGeo, vaporMat);
  vaporL.position.set(3.6, 0, 1.8); vaporL.rotation.y = Math.PI / 2; root.add(vaporL);

  const vaporR = new THREE.Mesh(vaporGeo, vaporMat.clone());
  vaporR.position.set(-3.6, 0, 1.8); vaporR.rotation.y = -Math.PI / 2; root.add(vaporR);

  root.userData.vaporL = vaporL;
  root.userData.vaporR = vaporR;

  // Dust
  const dustGeo = new THREE.PlaneGeometry(6, 3);
  dustGeo.rotateX(-Math.PI/2);
  const dust = new THREE.Mesh(dustGeo, new THREE.MeshBasicMaterial({ color: 0xaaaaaa, transparent: true, opacity: 0.0, depthWrite: false }));
  dust.position.set(0, -1.2, 1);
  root.add(dust);
  root.userData.dust = dust;

  return root;
}

/* =========================
   World (Terrain + Hill Grid + Runway + Trees)
========================= */
function createWorld() {
  const size = WORLD.size;
  const segments = WORLD.segments;

  const groundGeo = new THREE.PlaneGeometry(size, size, segments, segments);
  const pos = groundGeo.attributes.position;

  for (let i = 0; i < pos.count; i++) {
    const x = pos.getX(i);
    const zPlane = pos.getY(i); // becomes WORLD Z after rotate

    // raw height above base ground (mesh local Z)
    const h = terrainHeightRaw(x, zPlane);
    pos.setZ(i, h);
  }
  pos.needsUpdate = true;
  groundGeo.computeVertexNormals();

  // Terrain
  const ground = new THREE.Mesh(groundGeo, new THREE.MeshStandardMaterial({
    color: 0x365c3c, roughness: 0.95, metalness: 0.0
  }));
  ground.rotation.x = -Math.PI/2;
  ground.position.y = WORLD.groundY;
  ground.receiveShadow = true;
  scene.add(ground);

  // Hill grid overlay (wireframe) — THIS is your grid now (no GridHelper)
  const groundGrid = new THREE.Mesh(groundGeo.clone(), new THREE.MeshBasicMaterial({
    color: 0x111111,
    wireframe: true,
    transparent: true,
    opacity: 0.22,
    depthWrite: false,
    polygonOffset: true,
    polygonOffsetFactor: -1,
    polygonOffsetUnits: -1
  }));
  groundGrid.rotation.x = -Math.PI/2;
  groundGrid.position.y = WORLD.groundY + 0.02;
  groundGrid.renderOrder = 2;
  scene.add(groundGrid);

  // Runway (flat)
  const runway = new THREE.Mesh(new THREE.PlaneGeometry(60, 3500), new THREE.MeshStandardMaterial({
    color: 0x222428, roughness: 0.8, metalness: 0.1
  }));
  runway.rotation.x = -Math.PI/2;
  runway.position.y = WORLD.runwayY;
  runway.receiveShadow = true;
  runway.castShadow = true;
  scene.add(runway);

  // Runway markings
  const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
  for (let z = -1600; z <= 1600; z += 200) {
    const mark = new THREE.Mesh(new THREE.PlaneGeometry(2.2, 40), lineMat);
    mark.rotation.x = -Math.PI/2;
    mark.position.set(0, WORLD.runwayY + 0.05, z);
    scene.add(mark);
  }

  const edgeMat = new THREE.MeshBasicMaterial({ color: 0xe0e0e0 });
  const leftEdge = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 3500), edgeMat);
  leftEdge.rotation.x = -Math.PI/2;
  leftEdge.position.set(-29.5, WORLD.runwayY + 0.04, 0);
  scene.add(leftEdge);
  const rightEdge = leftEdge.clone();
  rightEdge.position.x = 29.5;
  scene.add(rightEdge);

  const TDZmat = new THREE.MeshBasicMaterial({ color: 0xf5f5f5 });
  for (let side of [-10, 10]) {
    for (let i = 0; i < 4; i++) {
      const stripe = new THREE.Mesh(new THREE.PlaneGeometry(4, 20), TDZmat);
      stripe.rotation.x = -Math.PI/2;
      stripe.position.set(side, WORLD.runwayY + 0.06, -1600 + i * 30);
      scene.add(stripe);
    }
  }

  // Trees: Instanced, placed ON TOP of the terrain height (won’t sink)
  const treeCount = 550;

  const trunkGeo = new THREE.CylinderGeometry(0.5, 0.7, 6, 6);
  const trunkMat = new THREE.MeshLambertMaterial({ color: 0x4a3018 });
  const leafGeo = new THREE.ConeGeometry(5, 16, 10);
  const leafMat = new THREE.MeshLambertMaterial({ vertexColors: true });

  const trunkInst = new THREE.InstancedMesh(trunkGeo, trunkMat, treeCount);
  const leafInst  = new THREE.InstancedMesh(leafGeo, leafMat, treeCount);

  trunkInst.castShadow = false; trunkInst.receiveShadow = false;
  leafInst.castShadow = false;  leafInst.receiveShadow = false;

  const tmpMat = new THREE.Matrix4();
  const tmpPos = new THREE.Vector3();
  const tmpQuat = new THREE.Quaternion();
  const tmpScale = new THREE.Vector3();
  const rotY = new THREE.Euler(0, 0, 0);

  let placed = 0;
  let attempts = 0;

  while (placed < treeCount && attempts < treeCount * 10) {
    attempts++;

    const x = (Math.random() - 0.5) * 7000;
    const z = (Math.random() - 0.5) * 7000;

    // keep runway clear
    if (Math.abs(x) < RUNWAY.halfW + 30 && Math.abs(z) < RUNWAY.halfL + 200) continue;

    const groundY = getGroundHeight(x, z);

    const s = 0.6 + Math.random() * 1.1;
    const yaw = Math.random() * Math.PI * 2;

    rotY.set(0, yaw, 0);
    tmpQuat.setFromEuler(rotY);
    tmpScale.set(s, s, s);

    // trunk center at ground + 3*s
    tmpPos.set(x, groundY + 3.0 * s, z);
    tmpMat.compose(tmpPos, tmpQuat, tmpScale);
    trunkInst.setMatrixAt(placed, tmpMat);

    // leaves center at ground + 14*s
    tmpPos.set(x, groundY + 14.0 * s, z);
    tmpMat.compose(tmpPos, tmpQuat, tmpScale);
    leafInst.setMatrixAt(placed, tmpMat);

    const c = new THREE.Color().setHSL(0.15 + Math.random() * 0.2, 0.8, 0.28 + Math.random() * 0.22);
    leafInst.setColorAt(placed, c);

    placed++;
  }

  trunkInst.instanceMatrix.needsUpdate = true;
  leafInst.instanceMatrix.needsUpdate = true;
  if (leafInst.instanceColor) leafInst.instanceColor.needsUpdate = true;

  scene.add(trunkInst);
  scene.add(leafInst);
}

/* =========================
   Utils + Loop
========================= */
function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
  requestAnimationFrame(animate);
  const dt = Math.min(clock.getDelta(), 0.1);
  updatePhysics(dt);
  updateHUD();
  updateCamera();
  renderer.render(scene, camera);
}

window.addEventListener('load', init);
</script>
</body>
</html>
