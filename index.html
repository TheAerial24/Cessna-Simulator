<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>3D Flight Demo</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Courier New', Courier, monospace; touch-action: none; }
    #canvas-container { width: 100vw; height: 100vh; display: block; }

    /* HUD Styles */
    #hud {
      position: absolute;
      top: 20px;
      left: 20px;
      color: #0f0;
      background: rgba(0, 0, 0, 0.5);
      padding: 15px;
      border-radius: 8px;
      pointer-events: none;
      user-select: none;
      border: 2px solid #0f0;
      box-shadow: 0 0 10px #0f0;
      z-index: 10;
      min-width: 150px;
    }
    .hud-row { margin-bottom: 5px; font-weight: bold; display: flex; justify-content: space-between; }
    .hud-label { margin-right: 10px; }
    .warning { color: red; animation: blink 0.5s infinite; display: none; text-align: center; margin-top: 5px;}
    @keyframes blink { 50% { opacity: 0; } }

    /* Help Text */
    #controls-help {
      position: absolute;
      top: 20px;
      right: 20px;
      text-align: right;
      color: white;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
      font-family: sans-serif;
      font-size: 12px;
      pointer-events: none;
      z-index: 10;
      display: none;
    }
    @media (min-width: 800px) { #controls-help { display: block; } }

    /* Overlays */
    #overlay-msg, #start-screen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-family: sans-serif;
      font-weight: bold;
      background: rgba(0,0,0,0.8);
      padding: 30px;
      border-radius: 10px;
      text-align: center;
      z-index: 20;
      cursor: pointer;
      border: 2px solid white;
      max-width: min(560px, calc(100vw - 40px));
    }
    #overlay-msg { display: none; font-size: 24px; }
    #start-screen { display: flex; flex-direction: column; align-items: center; gap: 10px; }

    h1 { margin: 0 0 10px 0; font-size: 28px; text-transform: uppercase; color: #87CEEB; }
    p { margin: 5px 0; color: #ddd; }
    .key { background: #333; padding: 2px 6px; border-radius: 4px; border: 1px solid #666; font-family: monospace; }
    .btn-start {
      margin-top: 20px;
      padding: 10px 30px;
      font-size: 20px;
      background: #2196F3;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    .btn-start:hover { background: #1976D2; }

    /* Throttle & Reset */
    .touch-control {
      position: absolute;
      z-index: 15;
      user-select: none;
      touch-action: none;
    }

    #throttle-container {
      bottom: 40px;
      left: 40px;
      width: 40px;
      height: 200px;
      background: rgba(0, 0, 0, 0.3);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 20px;
    }
    #throttle-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 0%;
      background: #ffcc00;
      border-radius: 18px;
      pointer-events: none;
    }
    #throttle-label {
      position: absolute;
      top: -25px;
      left: 0;
      width: 100%;
      text-align: center;
      color: white;
      font-weight: bold;
      font-size: 12px;
      text-shadow: 1px 1px 0 #000;
    }

    #reset-btn {
      bottom: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      background: rgba(255, 0, 0, 0.5);
      border: 2px solid white;
      border-radius: 8px;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      cursor: pointer;
    }
  </style>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
</head>
<body>

<div id="hud">
  <div class="hud-row"><span class="hud-label">SPD:</span> <span id="speed-display">0</span> kts</div>
  <div class="hud-row"><span class="hud-label">ALT:</span> <span id="alt-display">0</span> ft</div>
  <div class="hud-row"><span class="hud-label">HDG:</span> <span id="hdg-display">0</span>°</div>
  <div class="hud-row"><span class="hud-label">THR:</span> <span id="thr-display">0</span>%</div>
  <div class="hud-row"><span class="hud-label">VSI:</span> <span id="vsi-display">0</span> fpm</div>
  <div class="hud-row"><span class="hud-label">AOA:</span> <span id="aoa-display">0</span>°</div>
  <div class="hud-row"><span class="hud-label">G:</span> <span id="g-display">1.0</span></div>
  <div class="hud-row"><span class="hud-label">GEAR:</span> <span id="gear-display">DWN</span></div>
  <div id="brake-warning" class="warning">BRAKE</div>
  <div id="stall-warning" class="warning">STALL</div>
</div>

<div id="controls-help">
  <b>Controls:</b><br>
  <span class="key">W</span> / <span class="key">S</span> - Throttle <br>
  <span class="key">A</span> - Afterburner <br>
  <span class="key">Space</span> - Air Brake / Brake<br>
  <span class="key">G</span> - Landing Gear<br>
  Arrows - Pitch/Roll <br>
  <span class="key">Q</span> / <span class="key">E</span> - Rudder<br>
  <i>Hold Down Arrow at 110kts to Fly</i>
</div>

<div id="start-screen" onclick="startGame()">
  <h1>3D Flight Demo</h1>
  <p>Click to Start</p>
  <p>Use <span class="key">W</span> to Throttle Up</p>
  <p>Hold <span class="key">A</span> for Afterburner</p>
  <p>Hold <span class="key">Space</span> for Air Brake / Brakes</p>
  <p>Use <span class="key">G</span> for Landing Gear</p>
  <p>Use <span class="key">Arrows</span> to Steer/Fly</p>
  <button class="btn-start">START FLIGHT</button>
</div>

<div id="overlay-msg" onclick="resetPlane()">CRASH<br>Tap to Restart</div>

<div id="throttle-container" class="touch-control">
  <div id="throttle-label">THR</div>
  <div id="throttle-fill"></div>
</div>

<div id="reset-btn" class="touch-control" onclick="resetPlane()">R</div>

<div id="canvas-container"></div>

<script>
/* =========================
   Globals
========================= */
let scene, camera, renderer, clock;
let plane;
let gameActive = false;

// Physics & Sim State
let PHYSICS = {};
let sim = {};

// Audio (optional file)
let stallAudio = null;

const VISUALS = {
  colors: {
    fuselage: 0xb0b7c0,
    glass: 0x112244,
    tire: 0x111111,
    exhaust: 0x444444
  }
};

// Inputs
let input = { pitch: 0, roll: 0, yaw: 0, throttle: 0 };
let keys = {};

/* =========================
   World & Terrain (mountains + valley + triangle grid)
========================= */
const WORLD = { size: 40000, segments: 140, runwayY: 0.2, groundY: -0.05 };
const RUNWAY = { halfW: 80, halfL: 2100 };
const RUNWAY_VISUAL_WIDTH = 120;
const RUNWAY_VISUAL_LENGTH = 3500;

const SPAWN = { x: 0, z: 1200, flatRadius: 850, fade: 650 };
const VALLEY = {
  halfW: RUNWAY.halfW + 900,
  halfL: RUNWAY.halfL + 900,
  fadeW: 950,
  fadeL: 950,
  floorDrop: 3.0
};

const TERRAIN = { ready: false, size: WORLD.size, seg: WORLD.segments, geo: null, meshY: WORLD.groundY };

function clamp01(v){ return v < 0 ? 0 : (v > 1 ? 1 : v); }
function smoothstep(edge0, edge1, x) {
  const t = THREE.MathUtils.clamp((x - edge0) / (edge1 - edge0), 0, 1);
  return t * t * (3 - 2 * t);
}
function rectBlend(ax, az, halfW, halfL, fadeW, fadeL) {
  const dx = Math.max(0, ax - halfW);
  const dz = Math.max(0, az - halfL);
  const fx = smoothstep(0, fadeW, dx);
  const fz = smoothstep(0, fadeL, dz);
  return Math.max(fx, fz);
}
function circleBlend(x, z, cx, cz, radius, fade) {
  const d = Math.max(0, Math.hypot(x - cx, z - cz) - radius);
  return smoothstep(0, fade, d);
}
function isOnRunwayXZ(x, z) { return (Math.abs(x) < RUNWAY.halfW && Math.abs(z) < RUNWAY.halfL); }
function valleyBlend(x, z) {
  const ax = Math.abs(x);
  const az = Math.abs(z);
  const bRect = rectBlend(ax, az, VALLEY.halfW, VALLEY.halfL, VALLEY.fadeW, VALLEY.fadeL);
  const bCirc = circleBlend(x, z, SPAWN.x, SPAWN.z, SPAWN.flatRadius, SPAWN.fade);
  return Math.min(bRect, bCirc);
}

/* Hills features */
const HILLS = [];
function mulberry32(seed) {
  return function() {
    let t = seed += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function initHillFeatures() {
  HILLS.length = 0;
  const rand = mulberry32(1337);
  const count = 44;

  for (let i = 0; i < count; i++) {
    let x = 0, z = 0, tries = 0;
    while (tries++ < 60) {
      x = (rand() - 0.5) * 15000;
      z = (rand() - 0.5) * 15000;
      if (Math.abs(x) < (VALLEY.halfW + VALLEY.fadeW) && Math.abs(z) < (VALLEY.halfL + VALLEY.fadeL)) continue;
      if (Math.hypot(x - SPAWN.x, z - SPAWN.z) < (SPAWN.flatRadius + SPAWN.fade)) continue;
      break;
    }
    const radius = 260 + rand() * 1050;
    const height = 55 + Math.pow(rand(), 0.35) * 185;
    HILLS.push({ x, z, radius, height });
  }
}
function baseTerrainRaw(x, z) {
  const size = WORLD.size;
  const nx = x / size;
  const nz = z / size;
  const low  = Math.sin(nx * Math.PI * 4.0) * Math.cos(nz * Math.PI * 3.0) * 40;
  const mid  = Math.sin(nx * 2.3) * Math.sin(nz * 2.8) * 22;
  const hi   = Math.sin(nx * 10.0) * Math.cos(nz * 9.0) * 7;
  const ridge = 1.0 - Math.abs(Math.sin(nx * Math.PI * 3.6) * Math.cos(nz * Math.PI * 3.1));
  const ridgeShaped = Math.pow(ridge, 2.2) * 55;
  return (low + mid + hi) + ridgeShaped;
}
function featureHillsRaw(x, z) {
  let h = 0;
  for (let i = 0; i < HILLS.length; i++) {
    const f = HILLS[i];
    const dx = x - f.x, dz = z - f.z;
    const d2 = dx*dx + dz*dz;
    const r2 = f.radius * f.radius;
    const w = Math.exp(-d2 / (2 * r2));
    h += f.height * w;
  }
  return h;
}
function terrainWorldHeightOffRunway_Analytic(x, z) {
  const raw = WORLD.groundY + baseTerrainRaw(x, z) + featureHillsRaw(x, z);
  const valleyFloor = WORLD.runwayY - VALLEY.floorDrop;
  const b = valleyBlend(x, z);
  return THREE.MathUtils.lerp(valleyFloor, raw, b);
}
function getTerrainMeshWorldHeight_Analytic(x, z) {
  if (isOnRunwayXZ(x, z)) return WORLD.runwayY - VALLEY.floorDrop;
  return terrainWorldHeightOffRunway_Analytic(x, z);
}

function sampleTerrainMeshHeightAndNormal(x, z) {
  const size = TERRAIN.size;
  const seg = TERRAIN.seg;
  const vertsPer = seg + 1;

  const u = clamp01((x / size) + 0.5);
  const v = clamp01((z / size) + 0.5);

  const fx = u * seg;
  const fz = v * seg;

  const x0 = Math.floor(fx), z0 = Math.floor(fz);
  const x1 = Math.min(x0 + 1, seg), z1 = Math.min(z0 + 1, seg);

  const tx = fx - x0;
  const tz = fz - z0;

  const pos = TERRAIN.geo.attributes.position;
  const nor = TERRAIN.geo.attributes.normal;

  function idx(ix, iz){ return iz * vertsPer + ix; }

  const i00 = idx(x0, z0), i10 = idx(x1, z0), i01 = idx(x0, z1), i11 = idx(x1, z1);

  const h00 = pos.getZ(i00), h10 = pos.getZ(i10), h01 = pos.getZ(i01), h11 = pos.getZ(i11);
  const h0 = h00 + (h10 - h00) * tx;
  const h1 = h01 + (h11 - h01) * tx;
  const hLocal = h0 + (h1 - h0) * tz;

  const n00 = new THREE.Vector3(nor.getX(i00), nor.getY(i00), nor.getZ(i00));
  const n10 = new THREE.Vector3(nor.getX(i10), nor.getY(i10), nor.getZ(i10));
  const n01 = new THREE.Vector3(nor.getX(i01), nor.getY(i01), nor.getZ(i01));
  const n11 = new THREE.Vector3(nor.getX(i11), nor.getY(i11), nor.getZ(i11));

  const n0 = n00.lerp(n10, tx);
  const n1 = n01.lerp(n11, tx);
  const nLocal = n0.lerp(n1, tz).normalize();

  // plane mesh rotated -PI/2 about X, so convert local normal to world-ish
  const nWorld = nLocal.applyEuler(new THREE.Euler(-Math.PI/2, 0, 0)).normalize();
  const worldH = TERRAIN.meshY + hLocal;
  return { h: worldH, n: nWorld };
}

function getGroundHeight(x, z) {
  if (isOnRunwayXZ(x, z)) return WORLD.runwayY;
  if (TERRAIN.ready) return sampleTerrainMeshHeightAndNormal(x, z).h;
  return terrainWorldHeightOffRunway_Analytic(x, z);
}

/* =========================
   Start / Init
========================= */
function startGame() {
  document.getElementById('start-screen').style.display = 'none';
  gameActive = true;
  resetPlane();

  // prime audio after user interaction
  if (!stallAudio) {
    stallAudio = new Audio("stall_warning.mp3");
    stallAudio.loop = true;
    stallAudio.volume = 0.8;
  }
}

function init() {
  PHYSICS = {
    mass: 3500,
    gravity: 9.81,
    airDensity: 1.225,
    wingArea: 24.0,

    dragCoeffZero: 0.020,
    inducedDragFactor: 0.06,
    liftSlope: 7.5,
    maxLiftCoeff: 1.6,
    stallAngle: 0.45,
    wingIncidence: 0.02,

    maxThrust: 70000,

    momentInertia: new THREE.Vector3(12000, 15000, 12000),
    damping: new THREE.Vector3(2.5, 1.0, 5.0),

    wheelBrakes: 15000,
    wheelFriction: 0.09,
    wheelSideFriction: 15000,
    suspensionStiffness: 65000,
    suspensionDamping: 4000
  };

  sim = {
    pos: new THREE.Vector3(SPAWN.x, WORLD.runwayY + 1.35, SPAWN.z),
    vel: new THREE.Vector3(0, 0, 0),
    quat: new THREE.Quaternion(),
    angularVel: new THREE.Vector3(0, 0, 0),

    crashed: false,
    stalled: false,
    onGround: true,

    // Landing gear animation state:
    // gearPos: 1 = fully down, 0 = fully up
    gearPos: 1.0,
    gearTarget: 1.0,
    gearDown: true,

    afterburner: false,
    airBrake: false,

    alpha: 0,
    gLoad: 1.0
  };

  initHillFeatures();

  const container = document.getElementById('canvas-container');
  clock = new THREE.Clock();

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87CEEB);
  scene.fog = new THREE.Fog(0xbfd5ff, 4500, 26000);

  renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.5));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.05;
  container.appendChild(renderer.domElement);

  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 30000);

  // Sky dome
  const skyGeo = new THREE.SphereGeometry(12000, 32, 15);
  const skyMat = new THREE.ShaderMaterial({
    side: THREE.BackSide,
    uniforms: {
      topColor: { value: new THREE.Color(0x6fb6ff) },
      bottomColor: { value: new THREE.Color(0xf5fbff) },
      offset: { value: 33 },
      exponent: { value: 0.6 }
    },
    vertexShader: `
      varying vec3 vWorldPosition;
      void main() {
        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
        vWorldPosition = worldPosition.xyz;
        gl_Position = projectionMatrix * viewMatrix * worldPosition;
      }
    `,
    fragmentShader: `
      varying vec3 vWorldPosition;
      uniform vec3 topColor;
      uniform vec3 bottomColor;
      uniform float offset;
      uniform float exponent;
      void main() {
        float h = normalize(vWorldPosition + vec3(0.0, offset, 0.0)).y;
        float f = max(pow(max(h, 0.0), exponent), 0.0);
        vec3 col = mix(bottomColor, topColor, f);
        gl_FragColor = vec4(col, 1.0);
      }
    `
  });
  scene.add(new THREE.Mesh(skyGeo, skyMat));

  // Lights
  scene.add(new THREE.AmbientLight(0xffffff, 0.35));
  scene.add(new THREE.HemisphereLight(0xe6f1ff, 0x1e2a16, 0.35));

  const sun = new THREE.DirectionalLight(0xffffff, 1.15);
  sun.position.set(300, 600, 200);
  sun.castShadow = true;
  sun.shadow.mapSize.width = 4096;
  sun.shadow.mapSize.height = 4096;
  sun.shadow.camera.near = 10;
  sun.shadow.camera.far = 6000;
  sun.shadow.camera.left = -1200;
  sun.shadow.camera.right = 1200;
  sun.shadow.camera.top = 1200;
  sun.shadow.camera.bottom = -1200;
  scene.add(sun);

  createWorld();
  plane = createJetMesh();
  scene.add(plane);

  // Ensure gear visible at start
  if (plane && plane.userData.gearGroup) plane.userData.gearGroup.visible = true;

  window.addEventListener('resize', onResize);
  document.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (e.code === 'KeyG') toggleGear();
  });
  document.addEventListener('keyup', e => keys[e.code] = false);

  animate();
}

function toggleGear() {
  // Animate toward a target instead of hiding immediately
  sim.gearTarget = (sim.gearTarget > 0.5) ? 0.0 : 1.0;

  // If extending, make sure gear is visible immediately
  if (sim.gearTarget > 0.5 && plane?.userData?.gearGroup) {
    plane.userData.gearGroup.visible = true;
  }
}

/* =========================
   Inputs
========================= */
function updateInputs() {
  if (!gameActive) return;

  let kYaw = (keys['KeyQ'] ? 1 : 0) - (keys['KeyE'] ? 1 : 0);

  if (keys['KeyW']) input.throttle += 0.015;
  if (keys['KeyS']) input.throttle -= 0.02;
  input.throttle = THREE.MathUtils.clamp(input.throttle, 0, 1);

  sim.afterburner = !!keys['KeyA'];
  sim.airBrake    = !!keys['Space'];

  let keyPitchCmd = 0;
  if (keys['ArrowDown']) keyPitchCmd = 0.97;
  if (keys['ArrowUp']) keyPitchCmd = -0.95;

  let keyRollCmd = 0;
  if (keys['ArrowRight']) keyRollCmd = 1;
  if (keys['ArrowLeft']) keyRollCmd = -1;

  if (sim.onGround) {
    if (kYaw === 0 && Math.abs(keyRollCmd) > 0) kYaw = keyRollCmd * 0.5;
  }

  input.pitch = THREE.MathUtils.clamp(keyPitchCmd, -1, 1);
  input.roll  = THREE.MathUtils.clamp(keyRollCmd, -1, 1);
  input.yaw   = THREE.MathUtils.clamp(kYaw, -1, 1);
}

/* =========================
   Gear animation (slow + hide when fully up)
========================= */
function updateGearAnimation(dt) {
  if (!plane) return;

  // Slower animation speed
  const speed = 3.0; // lower = slower
  sim.gearPos += (sim.gearTarget - sim.gearPos) * (1 - Math.exp(-speed * dt));

  // ease
  const t = THREE.MathUtils.clamp(sim.gearPos, 0, 1);
  const e = t * t * (3 - 2 * t); // smoothstep

  // Animate pivots (defined in createJetMesh)
  if (plane.userData.nosePivot) {
    plane.userData.nosePivot.rotation.x = THREE.MathUtils.lerp(-1.45, 0.0, e);
    plane.userData.nosePivot.position.y = THREE.MathUtils.lerp(-0.3, -0.9, e);
  }
  if (plane.userData.mainLPivot) {
    plane.userData.mainLPivot.rotation.z = THREE.MathUtils.lerp(1.35, 0.0, e);
    plane.userData.mainLPivot.position.y = THREE.MathUtils.lerp(-0.25, -0.9, e);
  }
  if (plane.userData.mainRPivot) {
    plane.userData.mainRPivot.rotation.z = THREE.MathUtils.lerp(-1.35, 0.0, e);
    plane.userData.mainRPivot.position.y = THREE.MathUtils.lerp(-0.25, -0.9, e);
  }

  // Keep sim.gearDown compatible with existing physics
  sim.gearDown = (sim.gearPos > 0.85);

  // Once fully UP, hide the gear group (reappears immediately on extend)
  if (plane.userData.gearGroup) {
    const fullyUp = (sim.gearPos <= 0.02 && sim.gearTarget === 0.0);
    plane.userData.gearGroup.visible = !fullyUp;
  }
}

/* =========================
   Physics
========================= */
function updatePhysics(dt) {
  if (sim.crashed) return;

  updateInputs();

  const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(sim.quat);
  const up      = new THREE.Vector3(0, 1, 0).applyQuaternion(sim.quat);
  const right   = new THREE.Vector3(1, 0, 0).applyQuaternion(sim.quat);

  const speed = sim.vel.length();
  const localVel = sim.vel.clone().applyQuaternion(sim.quat.clone().invert());

  let alpha = PHYSICS.wingIncidence;
  if (speed > 1) alpha += Math.atan2(-localVel.y, -localVel.z);
  sim.alpha = alpha;
  sim.stalled = Math.abs(alpha) > PHYSICS.stallAngle;

  const q = 0.5 * PHYSICS.airDensity * (speed * speed);

  let cl = PHYSICS.liftSlope * alpha;
  cl = THREE.MathUtils.clamp(cl, -PHYSICS.maxLiftCoeff, PHYSICS.maxLiftCoeff);

  let groundEffect = 1.0;
  if (sim.pos.y < 5.0) groundEffect = 1.2;

  const liftForce = up.clone().multiplyScalar(q * PHYSICS.wingArea * cl * groundEffect);

  const cd = PHYSICS.dragCoeffZero + (PHYSICS.inducedDragFactor * cl * cl);
  let dragMag = q * PHYSICS.wingArea * cd;
  if (sim.airBrake) dragMag *= 15.0;

  const dragForce = (speed > 0.1)
    ? sim.vel.clone().normalize().negate().multiplyScalar(dragMag)
    : new THREE.Vector3();

  let currentThrottle = input.throttle;
  let abBoost = 1.0;

  if (sim.airBrake) currentThrottle = 0;
  else if (sim.afterburner) { currentThrottle = 1.1; abBoost = 2.0; }

  const thrustFactor = Math.max(0.4, 1 - (speed / 350));
  const thrustForce = forward.clone().multiplyScalar(currentThrottle * PHYSICS.maxThrust * thrustFactor * abBoost);

  // Visuals: afterburner flames
  if (plane && plane.userData.afterburners) {
    const speedFactor = THREE.MathUtils.clamp(speed / 250, 0, 1.2);
    plane.userData.afterburners.forEach((ab, idx) => {
      ab.visible = sim.afterburner;
      if (!sim.afterburner) return;
      const flicker = 0.8 + Math.random() * 0.4;
      const base = (idx === 0) ? 1.0 : 0.6;
      const s = base * (1.0 + 0.6 * speedFactor) * flicker;
      if (idx === 0) ab.scale.set(s, s, s * 1.8);
      else ab.scale.set(s * 0.6, s * 0.6, s * 1.4);
    });
  }

  // Visuals: airbrake panels
  if (plane) {
    const brakeSpeed = 5.0 * dt;
    const targetRot = sim.airBrake ? 0.9 : 0;
    if (plane.userData.airBrakeL) {
      const currentL = plane.userData.airBrakeL.rotation.y;
      plane.userData.airBrakeL.rotation.y += (targetRot - currentL) * brakeSpeed;
    }
    if (plane.userData.airBrakeR) {
      const currentR = plane.userData.airBrakeR.rotation.y;
      plane.userData.airBrakeR.rotation.y += (-targetRot - currentR) * brakeSpeed;
    }
  }

  const gravityForce = new THREE.Vector3(0, -PHYSICS.gravity * PHYSICS.mass, 0);

  const totalForce = new THREE.Vector3()
    .add(liftForce)
    .add(dragForce)
    .add(thrustForce)
    .add(gravityForce);

  // Ground handling (runway only). Off-runway: crash on any contact.
  const gearHeight  = 1.35;
  const bellyHeight = 0.5;

  const groundH = getGroundHeight(sim.pos.x, sim.pos.z);
  const onRunway = isOnRunwayXZ(sim.pos.x, sim.pos.z);
  const wasOnGround = sim.onGround;

  let suspensionTorque = 0;

  if (!onRunway) {
    // Off-runway: crash if we hit anything
    const contactOffset = sim.gearDown ? gearHeight : bellyHeight;
    if (sim.pos.y <= groundH + contactOffset) {
      sim.crashed = true;
      document.getElementById('overlay-msg').innerHTML = "CRASH<br>Click to Reset";
      document.getElementById('overlay-msg').style.display = 'block';
      return;
    }
    sim.onGround = false;
  } else {
    if (sim.gearDown) {
      const contactY = groundH + gearHeight;
      sim.onGround = (sim.pos.y <= contactY);

      if (sim.onGround) {
        if (sim.pos.y < contactY) sim.pos.y = contactY;

        // touchdown dust
        if (!wasOnGround && plane && plane.userData.dust) {
          const touchdownSpeed = sim.vel.length();
          plane.userData.dust.material.opacity = THREE.MathUtils.clamp(touchdownSpeed / 60, 0.2, 0.8);

          const trackDirLocal = sim.vel.clone();
          trackDirLocal.y = 0;
          trackDirLocal.applyQuaternion(sim.quat.clone().invert());
          if (trackDirLocal.lengthSq() > 0.1) {
            trackDirLocal.normalize();
            const yaw = Math.atan2(trackDirLocal.x, trackDirLocal.z);
            plane.userData.dust.rotation.y = yaw;
          }
        }

        if (sim.vel.y < 0) {
          sim.vel.y = 0;
          if (totalForce.y < 0) totalForce.y = 0;
        }

        const normalForce = Math.max(0, PHYSICS.mass * PHYSICS.gravity - liftForce.y);
        const frictionMag = normalForce * PHYSICS.wheelFriction;

        if (speed > 0.1) totalForce.add(sim.vel.clone().normalize().negate().multiplyScalar(frictionMag));
        if (sim.airBrake && speed > 0.5) totalForce.add(sim.vel.clone().normalize().negate().multiplyScalar(normalForce * 0.6));

        const sideVel = sim.vel.dot(right);
        totalForce.add(right.clone().multiplyScalar(-sideVel * 2.0 * PHYSICS.mass * dt));

        if (speed > 1) sim.angularVel.y += input.yaw * 0.8 * dt;

        const euler = new THREE.Euler().setFromQuaternion(sim.quat, 'YXZ');
        if (euler.x < 0) {
          suspensionTorque += -euler.x * PHYSICS.suspensionStiffness;
          suspensionTorque -= sim.angularVel.x * PHYSICS.suspensionDamping;
        } else if (euler.x > 0.3) {
          suspensionTorque += -(euler.x - 0.3) * PHYSICS.suspensionStiffness;
        }
      }
    } else {
      sim.onGround = false;
      const bellyContactY = groundH + bellyHeight;
      if (sim.pos.y < bellyContactY) {
        sim.crashed = true;
        document.getElementById('overlay-msg').innerHTML = "CRASH<br>Click to Reset";
        document.getElementById('overlay-msg').style.display = 'block';
        return;
      }
    }
  }

  const controlScale = (q * PHYSICS.wingArea) / 2500;

  let yawStability = 0;
  if (speed > 50) yawStability = -localVel.x * 6.25 * controlScale;

  const stabilityPitch = -alpha * 40000;
  const controlPitch = input.pitch * 45000;

  const effectiveQ = Math.max(q, 100);
  let pitchTorque = (stabilityPitch + controlPitch) * (effectiveQ / 2000);
  pitchTorque += suspensionTorque;

  const controlRoll = -input.roll * 1750 * controlScale;
  const controlYaw  = (input.yaw * 2000 * controlScale) + yawStability;

  const torqueLocal = new THREE.Vector3(pitchTorque, controlYaw, controlRoll);

  // G-load
  const accelNoDt = totalForce.clone().divideScalar(PHYSICS.mass);
  const properAccel = accelNoDt.clone().sub(new THREE.Vector3(0, -PHYSICS.gravity, 0));
  sim.gLoad = THREE.MathUtils.clamp(properAccel.dot(up) / PHYSICS.gravity, -3, 9);

  // integrate linear
  sim.vel.add(totalForce.divideScalar(PHYSICS.mass).multiplyScalar(dt));
  sim.pos.add(sim.vel.clone().multiplyScalar(dt));

  // integrate angular
  const angAccel = new THREE.Vector3(
    torqueLocal.x / PHYSICS.momentInertia.x,
    torqueLocal.y / PHYSICS.momentInertia.y,
    torqueLocal.z / PHYSICS.momentInertia.z
  );

  sim.angularVel.multiplyScalar(1.0 - (2.0 * dt));
  sim.angularVel.add(angAccel.multiplyScalar(dt));

  const rotMag = sim.angularVel.length();
  if (rotMag > 0.0001) {
    const deltaRot = new THREE.Quaternion().setFromAxisAngle(sim.angularVel.clone().normalize(), rotMag * dt);
    sim.quat.multiply(deltaRot).normalize();
  }

  if (sim.onGround) {
    const euler = new THREE.Euler().setFromQuaternion(sim.quat, 'YXZ');
    euler.z *= 0.95;
    sim.quat.setFromEuler(euler);
    sim.angularVel.z *= 0.8;
  }

  // vapor
  if (plane && plane.userData.vaporL) {
    const aoaStrength = THREE.MathUtils.clamp(Math.abs(sim.alpha) / PHYSICS.stallAngle, 0, 1);
    const speedFactor = THREE.MathUtils.clamp(speed / 120, 0, 1);
    const vaporOpacity = aoaStrength * speedFactor;

    plane.userData.vaporL.material.opacity = vaporOpacity;
    plane.userData.vaporR.material.opacity = vaporOpacity;

    if (speed > 1) {
      const flowLocal = sim.vel.clone().applyQuaternion(sim.quat.clone().invert()).normalize().negate();
      const vaporQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), flowLocal);
      plane.userData.vaporL.quaternion.copy(vaporQuat);
      plane.userData.vaporR.quaternion.copy(vaporQuat);
    }
  }

  // dust fade-out
  if (plane && plane.userData.dust) {
    plane.userData.dust.material.opacity *= 0.75;
    plane.userData.dust.material.opacity -= 0.6 * dt;
    if (plane.userData.dust.material.opacity < 0) plane.userData.dust.material.opacity = 0;
  }

  // below world => crash
  if (sim.pos.y < -50) {
    sim.crashed = true;
    document.getElementById('overlay-msg').innerHTML = "CRASH<br>Click to Reset";
    document.getElementById('overlay-msg').style.display = 'block';
    return;
  }

  plane.position.copy(sim.pos);
  plane.quaternion.copy(sim.quat);
}

/* =========================
   HUD / Camera / Reset
========================= */
function updateHUD() {
  if (!sim.vel) return;

  const spd = Math.round(sim.vel.length() * 1.9438);
  const groundBelow = getGroundHeight(sim.pos.x, sim.pos.z);
  const alt = Math.round((sim.pos.y - (groundBelow + 1.35)) * 3.2808);

  const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(sim.quat);
  let hdg = Math.round(Math.atan2(-fwd.x, -fwd.z) * 180 / Math.PI);
  if (hdg < 0) hdg += 360;

  const vsi = Math.round(sim.vel.y * 60 * 3.2808);
  const aoaDeg = Math.round((sim.alpha || 0) * 57.2958);
  const gLoad = sim.gLoad || 1.0;

  document.getElementById('speed-display').innerText = spd;
  document.getElementById('alt-display').innerText = alt;
  document.getElementById('hdg-display').innerText = hdg;

  let throttleVal = Math.round(input.throttle * 100);
  const thrEl = document.getElementById('thr-display');

  if (sim.airBrake) {
    throttleVal = 0;
    thrEl.style.color = '#fa0';
    thrEl.style.textShadow = 'none';
  } else if (sim.afterburner) {
    throttleVal = 110;
    thrEl.style.color = 'red';
    thrEl.style.textShadow = '0 0 5px red';
  } else {
    thrEl.style.color = '#0f0';
    thrEl.style.textShadow = 'none';
  }
  thrEl.innerText = throttleVal;

  document.getElementById('vsi-display').innerText = vsi;
  document.getElementById('aoa-display').innerText = aoaDeg;
  document.getElementById('g-display').innerText = gLoad.toFixed(1);

  const gearEl = document.getElementById('gear-display');
  if (sim.gearPos >= 0.95) {
    gearEl.innerText = "DWN";
    gearEl.style.color = "#0f0";
  } else if (sim.gearPos <= 0.05) {
    gearEl.innerText = "UP";
    gearEl.style.color = "#fa0";
  } else {
    gearEl.innerText = "TRN";
    gearEl.style.color = "#ff0";
  }

  document.getElementById('stall-warning').style.display = sim.stalled ? 'block' : 'none';
  document.getElementById('brake-warning').style.display = (sim.airBrake && sim.onGround) ? 'block' : 'none';

  // throttle bar
  let barHeight = input.throttle * 100;
  let barColor = '#ffcc00';
  if (sim.airBrake) barHeight = 0;
  else if (sim.afterburner) { barHeight = 100; barColor = 'red'; }
  document.getElementById('throttle-fill').style.height = barHeight + '%';
  document.getElementById('throttle-fill').style.backgroundColor = barColor;

  // stall audio (optional file)
  if (stallAudio) {
    if (sim.stalled) {
      if (stallAudio.paused) {
        stallAudio.currentTime = 0;
        stallAudio.play().catch(()=>{});
      }
    } else {
      if (!stallAudio.paused) stallAudio.pause();
    }
  }
}

function updateCamera() {
  if (!sim.pos) return;
  const offset = new THREE.Vector3(0, 5, 25).applyQuaternion(sim.quat);
  const target = sim.pos.clone().add(offset);
  if (target.y < 2) target.y = 2;
  camera.position.lerp(target, 0.1);
  camera.lookAt(sim.pos.clone());
}

function resetPlane() {
  sim.pos.set(SPAWN.x, WORLD.runwayY + 1.35, SPAWN.z);
  sim.vel.set(0, 0, 0);
  sim.quat.set(0, 0, 0, 1);
  sim.angularVel.set(0, 0, 0);

  sim.crashed = false;
  sim.stalled = false;
  sim.onGround = true;

  // Reset gear animation state
  sim.gearPos = 1.0;
  sim.gearTarget = 1.0;
  sim.gearDown = true;

  sim.afterburner = false;
  sim.airBrake = false;
  sim.alpha = 0;
  sim.gLoad = 1.0;

  input.throttle = 0;
  input.pitch = 0;
  input.roll = 0;
  input.yaw = 0;

  if (plane) {
    if (plane.userData.gearGroup) plane.userData.gearGroup.visible = true;
    if (plane.userData.airBrakeL) plane.userData.airBrakeL.rotation.y = 0;
    if (plane.userData.airBrakeR) plane.userData.airBrakeR.rotation.y = 0;
    if (plane.userData.dust) plane.userData.dust.material.opacity = 0;

    // Force pivots into "down" pose immediately
    updateGearAnimation(0.0001);
  }

  document.getElementById('throttle-fill').style.height = '0%';
  document.getElementById('overlay-msg').style.display = 'none';
}

/* =========================
   Jet Model (procedural)
========================= */
function createJetMesh() {
  const root = new THREE.Group();

  const matBody = new THREE.MeshStandardMaterial({
    color: VISUALS.colors.fuselage,
    metalness: 0.7,
    roughness: 0.28
  });
  const matGlass = new THREE.MeshPhysicalMaterial({
    color: VISUALS.colors.glass,
    metalness: 0.0,
    roughness: 0.1,
    transparent: true,
    opacity: 0.5,
    transmission: 0.7,
    clearcoat: 1.0,
    clearcoatRoughness: 0.15
  });
  const matExhaust = new THREE.MeshStandardMaterial({
    color: VISUALS.colors.exhaust,
    metalness: 0.9,
    roughness: 0.35,
    emissive: 0x111111,
    emissiveIntensity: 0.4
  });

  // Fuselage
  const fuse = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.6, 12, 24), matBody);
  fuse.rotation.x = -Math.PI/2;
  fuse.castShadow = true;
  root.add(fuse);

  // Nose
  const nose = new THREE.Mesh(new THREE.ConeGeometry(0.6, 3, 24), matBody);
  nose.rotation.x = -Math.PI/2;
  nose.position.z = -7.5;
  nose.castShadow = true;
  root.add(nose);

  // Cockpit
  const cockpit = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 1.5, 8, 16), matGlass);
  cockpit.rotation.x = -Math.PI/2;
  cockpit.position.set(0, 0.8, -3);
  cockpit.castShadow = true;
  root.add(cockpit);

  // Air Brakes (left/right near engine)
  const airBrakeGeo = new THREE.BoxGeometry(0.12, 0.6, 1.5);
  airBrakeGeo.translate(0, 0, 0.75);

  const brakeL = new THREE.Mesh(airBrakeGeo, matBody);
  brakeL.position.set(0.9, 0, 4.2);
  brakeL.castShadow = true;
  root.add(brakeL);

  const brakeR = new THREE.Mesh(airBrakeGeo, matBody);
  brakeR.position.set(-0.9, 0, 4.2);
  brakeR.castShadow = true;
  root.add(brakeR);

  root.userData.airBrakeL = brakeL;
  root.userData.airBrakeR = brakeR;

  // Wings
  const wingShape = new THREE.Shape();
  const ww = 6, hh = 4, rr = 0.6;
  wingShape.absarc(ww/2 - rr, hh/2 - rr, rr, 0, Math.PI / 2, false);
  wingShape.absarc(-ww/2 + rr, hh/2 - rr, rr, Math.PI / 2, Math.PI, false);
  wingShape.absarc(-ww/2 + rr, -hh/2 + rr, rr, Math.PI, Math.PI * 1.5, false);
  wingShape.absarc(ww/2 - rr, -hh/2 + rr, rr, Math.PI * 1.5, Math.PI * 2, false);

  const wingGeo = new THREE.ExtrudeGeometry(wingShape, {
    depth: 0.09,
    bevelEnabled: true,
    bevelThickness: 0.03,
    bevelSize: 0.06,
    bevelSegments: 4
  });
  wingGeo.center();
  wingGeo.rotateX(Math.PI / 2);

  const wingL = new THREE.Mesh(wingGeo, matBody);
  wingL.position.set(2.5, 0, 1);
  wingL.rotation.y = -0.5;
  wingL.castShadow = true;
  root.add(wingL);

  const wingR = new THREE.Mesh(wingGeo, matBody);
  wingR.position.set(-2.5, 0, 1);
  wingR.rotation.y = 0.5;
  wingR.castShadow = true;
  root.add(wingR);

  // Exhaust
  const exGeo = new THREE.CylinderGeometry(0.7, 0.6, 0.8, 20);
  const exMesh = new THREE.Mesh(exGeo, matExhaust);
  exMesh.rotation.x = -Math.PI/2;
  exMesh.position.set(0, 0, 6.2);
  exMesh.castShadow = true;
  root.add(exMesh);

  // Afterburner flames
  const outerGeo = new THREE.ConeGeometry(0.5, 4.0, 16, 1, true);
  outerGeo.translate(0, 2.0, 0);
  outerGeo.rotateX(Math.PI / 2);

  const abOuterMat = new THREE.MeshBasicMaterial({
    color: 0xffaa33, transparent: true, opacity: 0.55,
    blending: THREE.AdditiveBlending, depthWrite: false
  });
  const flameOuter = new THREE.Mesh(outerGeo, abOuterMat);
  flameOuter.position.set(0, 0, 6.6);
  flameOuter.visible = false;
  root.add(flameOuter);

  const innerGeo = new THREE.ConeGeometry(0.3, 3.0, 16, 1, true);
  innerGeo.translate(0, 1.5, 0);
  innerGeo.rotateX(Math.PI / 2);

  const abInnerMat = new THREE.MeshBasicMaterial({
    color: 0x66c9ff, transparent: true, opacity: 0.8,
    blending: THREE.AdditiveBlending, depthWrite: false
  });
  const flameInner = new THREE.Mesh(innerGeo, abInnerMat);
  flameInner.position.set(0, 0, 6.7);
  flameInner.visible = false;
  root.add(flameInner);

  root.userData.afterburners = [flameOuter, flameInner];

  // Tail
  const tailGeo = new THREE.BoxGeometry(0.12, 3.1, 3);
  const tail = new THREE.Mesh(tailGeo, matBody);
  tail.position.set(0, 1.5, 5.1);
  tail.rotation.x = 0.55;
  tail.castShadow = true;
  root.add(tail);

  // Horizontal stab
  const hStabGeo = new THREE.BoxGeometry(3.7, 0.12, 2.1);
  const hStab = new THREE.Mesh(hStabGeo, matBody);
  hStab.position.set(0, 0.25, 5.6);
  hStab.rotation.x = -0.1;
  hStab.castShadow = true;
  root.add(hStab);

  // Gear group (animated pivots)
  const gearGroup = new THREE.Group();
  root.add(gearGroup);
  root.userData.gearGroup = gearGroup;

  const tireGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.25, 16);
  tireGeo.rotateZ(Math.PI/2);
  const tireMat = new THREE.MeshStandardMaterial({ color: VISUALS.colors.tire, roughness: 0.9, metalness: 0.0 });

  // Nose gear pivot
  const nosePivot = new THREE.Group();
  gearGroup.add(nosePivot);
  nosePivot.position.set(0, -0.9, -5.0);
  root.userData.nosePivot = nosePivot;

  const noseWheel = new THREE.Mesh(tireGeo, tireMat);
  noseWheel.position.set(0, -0.3, 0);
  noseWheel.castShadow = true;
  nosePivot.add(noseWheel);

  // Main left gear pivot
  const mainLPivot = new THREE.Group();
  gearGroup.add(mainLPivot);
  mainLPivot.position.set(1.4, -0.9, 1.0);
  root.userData.mainLPivot = mainLPivot;

  const mainWheelL = new THREE.Mesh(tireGeo, tireMat);
  mainWheelL.position.set(0, -0.3, 0);
  mainWheelL.castShadow = true;
  mainLPivot.add(mainWheelL);

  // Main right gear pivot
  const mainRPivot = new THREE.Group();
  gearGroup.add(mainRPivot);
  mainRPivot.position.set(-1.4, -0.9, 1.0);
  root.userData.mainRPivot = mainRPivot;

  const mainWheelR = new THREE.Mesh(tireGeo, tireMat);
  mainWheelR.position.set(0, -0.3, 0);
  mainWheelR.castShadow = true;
  mainRPivot.add(mainWheelR);

  // vapor
  const vaporMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.0, depthWrite: false });
  const vaporGeo = new THREE.PlaneGeometry(2, 0.4);

  const vaporL = new THREE.Mesh(vaporGeo, vaporMat);
  vaporL.position.set(3.6, 0, 1.8);
  vaporL.rotation.y = Math.PI / 2;
  root.add(vaporL);

  const vaporR = new THREE.Mesh(vaporGeo, vaporMat.clone());
  vaporR.position.set(-3.6, 0, 1.8);
  vaporR.rotation.y = -Math.PI / 2;
  root.add(vaporR);

  root.userData.vaporL = vaporL;
  root.userData.vaporR = vaporR;

  // dust
  const dustMat = new THREE.MeshBasicMaterial({ color: 0xaaaaaa, transparent: true, opacity: 0.0, depthWrite: false });
  const dustGeo = new THREE.PlaneGeometry(6, 3);
  dustGeo.rotateX(-Math.PI / 2);
  const dust = new THREE.Mesh(dustGeo, dustMat);
  dust.position.set(0, -1.2, 1);
  root.add(dust);
  root.userData.dust = dust;

  return root;
}

/* =========================
   World creation (mountains + triangle grid + runway + trees)
========================= */
function createWorld() {
  const size = WORLD.size;
  const segments = WORLD.segments;

  // Build terrain mesh
  const groundGeo = new THREE.PlaneGeometry(size, size, segments, segments);
  const pos = groundGeo.attributes.position;

  for (let i = 0; i < pos.count; i++) {
    const x = pos.getX(i);
    const zPlane = pos.getY(i);          // this becomes world Z after rotate
    const worldH = getTerrainMeshWorldHeight_Analytic(x, zPlane);
    const localZ = worldH - WORLD.groundY;
    pos.setZ(i, localZ);
  }
  pos.needsUpdate = true;
  groundGeo.computeVertexNormals();

  TERRAIN.ready = true;
  TERRAIN.geo = groundGeo;
  TERRAIN.seg = segments;
  TERRAIN.size = size;
  TERRAIN.meshY = WORLD.groundY;

  const ground = new THREE.Mesh(groundGeo, new THREE.MeshStandardMaterial({
    color: 0x365c3c, roughness: 0.95, metalness: 0.0
  }));
  ground.rotation.x = -Math.PI/2;
  ground.position.y = WORLD.groundY;
  ground.receiveShadow = true;
  scene.add(ground);

  // Triangle wireframe overlay (the “grid” on the mountains)
  const triMat = new THREE.MeshBasicMaterial({
    color: 0x000000,
    wireframe: true,
    transparent: true,
    opacity: 0.22
  });
  triMat.depthWrite = false;
  triMat.polygonOffset = true;
  triMat.polygonOffsetFactor = -1;
  triMat.polygonOffsetUnits = -1;

  const triGrid = new THREE.Mesh(groundGeo, triMat);
  triGrid.rotation.x = -Math.PI/2;
  triGrid.position.y = WORLD.groundY + 0.02;
  triGrid.renderOrder = 3;
  scene.add(triGrid);

  // Runway
  const runway = new THREE.Mesh(
    new THREE.PlaneGeometry(RUNWAY_VISUAL_WIDTH, RUNWAY_VISUAL_LENGTH),
    new THREE.MeshStandardMaterial({ color: 0x222428, roughness: 0.82, metalness: 0.08 })
  );
  runway.rotation.x = -Math.PI/2;
  runway.position.y = WORLD.runwayY;
  runway.receiveShadow = true;
  runway.castShadow = true;
  scene.add(runway);

  // Centerline dashes
  const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
  for (let z = -1600; z <= 1600; z += 200) {
    const mark = new THREE.Mesh(new THREE.PlaneGeometry(2.2, 40), lineMat);
    mark.rotation.x = -Math.PI/2;
    mark.position.set(0, WORLD.runwayY + 0.05, z);
    scene.add(mark);
  }

  // Edge lines
  const edgeMat = new THREE.MeshBasicMaterial({ color: 0xe0e0e0 });
  const leftEdge = new THREE.Mesh(new THREE.PlaneGeometry(1.5, RUNWAY_VISUAL_LENGTH), edgeMat);
  leftEdge.rotation.x = -Math.PI/2;
  leftEdge.position.set(-(RUNWAY_VISUAL_WIDTH/2) + 1.5, WORLD.runwayY + 0.04, 0);
  scene.add(leftEdge);

  const rightEdge = leftEdge.clone();
  rightEdge.position.x = (RUNWAY_VISUAL_WIDTH/2) - 1.5;
  scene.add(rightEdge);

  // Touchdown zone stripes
  const TDZmat = new THREE.MeshBasicMaterial({ color: 0xf5f5f5 });
  for (let side of [-10, 10]) {
    for (let i = 0; i < 4; i++) {
      const stripe = new THREE.Mesh(new THREE.PlaneGeometry(4, 20), TDZmat);
      stripe.rotation.x = -Math.PI/2;
      stripe.position.set(side, WORLD.runwayY + 0.06, -1600 + i * 30);
      scene.add(stripe);
    }
  }

  // Trees (placed on terrain height)
  const trunkGeo = new THREE.CylinderGeometry(0.5, 0.7, 6, 6);
  const trunkMat = new THREE.MeshLambertMaterial({ color: 0x4a3018 });
  const leafGeo = new THREE.ConeGeometry(5, 16, 12);

  for (let i = 0; i < 900; i++) {
    const x = (Math.random() - 0.5) * 4500;
    const z = (Math.random() - 0.5) * 4500;

    // don't put trees on runway zone
    if (Math.abs(x) < RUNWAY.halfW + 20 && Math.abs(z) < RUNWAY.halfL + 200) continue;

    const y = getGroundHeight(x, z);

    const tree = new THREE.Group();

    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
    trunk.position.y = 3;
    trunk.castShadow = false;
    tree.add(trunk);

    const c = new THREE.Color().setHSL(0.15 + Math.random() * 0.2, 0.8, 0.3 + Math.random() * 0.4);
    const leafMat = new THREE.MeshLambertMaterial({ color: c });
    const leaves = new THREE.Mesh(leafGeo, leafMat);
    leaves.position.y = 12;
    leaves.castShadow = true;
    tree.add(leaves);

    tree.position.set(x, y, z);
    const s = 0.6 + Math.random() * 0.9;
    tree.scale.set(s, s, s);
    tree.rotation.y = Math.random() * Math.PI * 2;
    scene.add(tree);
  }
}

/* =========================
   Loop / Resize
========================= */
function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
  requestAnimationFrame(animate);
  const dt = Math.min(clock.getDelta(), 0.1);
  updatePhysics(dt);
  updateGearAnimation(dt);
  updateHUD();
  updateCamera();
  renderer.render(scene, camera);
}

window.addEventListener('load', init);
</script>
</body>
</html>
