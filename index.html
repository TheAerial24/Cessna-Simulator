<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GitHub 3D Jet Sim</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Courier New', Courier, monospace; }
        #hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: lime;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border: 2px solid lime;
            border-radius: 5px;
            pointer-events: none;
            user-select: none;
        }
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>

<div id="instructions">
    <b>CONTROLS:</b><br>
    ⬆ / ⬇ : Pitch (Up/Down)<br>
    ⬅ / ➡ : Roll (Left/Right)<br>
    <b>W</b> / <b>S</b> : Throttle Control<br>
    (Fly through the hoops!)
</div>

<div id="hud">
    <div>THROTTLE: <span id="throtVal">0</span>%</div>
    <div>SPEED: <span id="spdVal">0</span> MACH</div>
    <div>ALTITUDE: <span id="altVal">0</span> FT</div>
</div>

<script type="module">
    import * as THREE from 'https://unpkg.com/three@0.126.0/build/three.module.js';

    // --- CONFIGURATION ---
    const MAX_SPEED = 2.5;
    const ACCELERATION = 0.01;
    const TURN_SPEED = 0.03;

    // --- SETUP SCENE ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); // Sky blue
    scene.fog = new THREE.Fog(0x87CEEB, 100, 500);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // --- LIGHTS ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(100, 200, 50);
    scene.add(dirLight);

    // --- BUILD THE JET ---
    const jetGroup = new THREE.Group();
    
    // Fuselage
    const geometryBody = new THREE.ConeGeometry(0.5, 3, 32);
    geometryBody.rotateX(Math.PI / 2);
    const materialGrey = new THREE.MeshPhongMaterial({ color: 0x999999, flatShading: true });
    const fuselage = new THREE.Mesh(geometryBody, materialGrey);
    jetGroup.add(fuselage);

    // Wings
    const geometryWings = new THREE.BoxGeometry(4, 0.1, 1.5);
    const materialDark = new THREE.MeshPhongMaterial({ color: 0x555555 });
    const wings = new THREE.Mesh(geometryWings, materialDark);
    wings.position.set(0, 0, 0.5);
    jetGroup.add(wings);

    // Tail
    const geometryTail = new THREE.BoxGeometry(1.5, 0.1, 1);
    const tail = new THREE.Mesh(geometryTail, materialDark);
    tail.position.set(0, 0, 1.4);
    jetGroup.add(tail);

    // Vertical Stabilizer
    const geometryStab = new THREE.BoxGeometry(0.1, 1, 1);
    const stabilizer = new THREE.Mesh(geometryStab, materialDark);
    stabilizer.position.set(0, 0.5, 1.4);
    jetGroup.add(stabilizer);

    // Engine glow
    const geometryEngine = new THREE.CylinderGeometry(0.3, 0.1, 0.5, 10);
    geometryEngine.rotateX(Math.PI / 2);
    const materialGlow = new THREE.MeshBasicMaterial({ color: 0xff4500 });
    const engine = new THREE.Mesh(geometryEngine, materialGlow);
    engine.position.z = 1.6;
    jetGroup.add(engine);

    scene.add(jetGroup);

    // --- ENVIRONMENT (Ground Grid) ---
    const gridHelper = new THREE.GridHelper(2000, 200, 0x555555, 0x999999);
    gridHelper.position.y = -50;
    scene.add(gridHelper);

    // --- GAME VARIABLES ---
    let throttle = 0; // 0 to 100
    let speed = 0;
    
    // Keys
    const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, w: false, s: false };

    // --- EVENT LISTENERS ---
    window.addEventListener('keydown', (e) => {
        if(keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.key.toLowerCase())) {
            keys[e.key] = true;
            keys[e.key.toLowerCase()] = true;
        }
    });
    window.addEventListener('keyup', (e) => {
        if(keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.key.toLowerCase())) {
            keys[e.key] = false;
            keys[e.key.toLowerCase()] = false;
        }
    });
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- GAME LOOP ---
    function animate() {
        requestAnimationFrame(animate);

        // 1. Handle Throttle (W/S)
        if (keys.w && throttle < 100) throttle += 0.5;
        if (keys.s && throttle > 0) throttle -= 0.5;

        // 2. Physics: Calculate Speed based on Throttle (Inertia)
        let targetSpeed = (throttle / 100) * MAX_SPEED;
        // Lerp speed towards target for realistic momentum
        speed += (targetSpeed - speed) * 0.02;

        // 3. Move Jet
        // translateZ moves the object forward relative to its own rotation
        jetGroup.translateZ(-speed); 

        // 4. Handle Rotation (Arrow Keys)
        // Pitch
        if (keys.ArrowUp) jetGroup.rotateX(-TURN_SPEED);
        if (keys.ArrowDown) jetGroup.rotateX(TURN_SPEED);
        // Roll
        if (keys.ArrowLeft) jetGroup.rotateZ(TURN_SPEED);
        if (keys.ArrowRight) jetGroup.rotateZ(-TURN_SPEED);

        // 5. Camera Follow Logic
        // Calculate desired camera position relative to jet
        const relativeCameraOffset = new THREE.Vector3(0, 3, 10);
        const cameraOffset = relativeCameraOffset.applyMatrix4(jetGroup.matrixWorld);
        
        // Smoothly move camera to that position
        camera.position.lerp(cameraOffset, 0.1);
        camera.lookAt(jetGroup.position);

        // 6. Infinite Terrain Illusion
        // Move the grid so it stays under the player
        gridHelper.position.x = jetGroup.position.x;
        gridHelper.position.z = jetGroup.position.z;

        // 7. Update HUD
        document.getElementById('throtVal').innerText = Math.round(throttle);
        document.getElementById('spdVal').innerText = speed.toFixed(2);
        document.getElementById('altVal').innerText = Math.round(jetGroup.position.y + 50); // Offset by ground level

        renderer.render(scene, camera);
    }

    animate();
</script>
</body>
</html>
