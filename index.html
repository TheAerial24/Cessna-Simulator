<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>3D Flight Demo</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Courier New', Courier, monospace; touch-action: none; }
    #canvas-container { width: 100vw; height: 100vh; display: block; }

    #hud {
      position: absolute; top: 20px; left: 20px;
      color: #0f0; background: rgba(0,0,0,0.5);
      padding: 15px; border-radius: 8px;
      pointer-events: none; user-select: none;
      border: 2px solid #0f0; box-shadow: 0 0 10px #0f0;
      z-index: 10; min-width: 150px;
    }
    .hud-row { margin-bottom: 5px; font-weight: bold; display: flex; justify-content: space-between; }
    .hud-label { margin-right: 10px; }
    .warning { color: red; animation: blink 0.5s infinite; display: none; text-align: center; margin-top: 5px; }
    @keyframes blink { 50% { opacity: 0; } }

    #controls-help {
      position: absolute; top: 20px; right: 20px;
      text-align: right; color: white;
      background: rgba(0,0,0,0.5);
      padding: 10px; border-radius: 5px;
      font-family: sans-serif; font-size: 12px;
      pointer-events: none; z-index: 10; display: none;
    }
    @media (min-width: 800px) { #controls-help { display: block; } }

    #overlay-msg, #start-screen {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      color: white; font-family: sans-serif; font-weight: bold;
      background: rgba(0,0,0,0.8);
      padding: 30px; border-radius: 10px; text-align: center;
      z-index: 20; cursor: pointer; border: 2px solid white;
    }
    #overlay-msg { display: none; font-size: 24px; }
    #start-screen { display: flex; flex-direction: column; align-items: center; gap: 10px; }

    h1 { margin: 0 0 10px 0; font-size: 28px; text-transform: uppercase; color: #87CEEB; }
    p { margin: 5px 0; color: #ddd; }
    .key { background: #333; padding: 2px 6px; border-radius: 4px; border: 1px solid #666; font-family: monospace; }
    .btn-start {
      margin-top: 20px;
      padding: 10px 30px;
      font-size: 20px;
      background: #2196F3;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    .btn-start:hover { background: #1976D2; }

    .touch-control { position: absolute; z-index: 15; user-select: none; touch-action: none; }

    #throttle-container {
      bottom: 40px; left: 40px;
      width: 40px; height: 200px;
      background: rgba(0,0,0,0.3);
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 20px;
    }
    #throttle-fill {
      position: absolute; bottom: 0; left: 0;
      width: 100%; height: 0%;
      background: #ffcc00;
      border-radius: 18px;
      pointer-events: none;
    }
    #throttle-label {
      position: absolute; top: -25px; left: 0; width: 100%;
      text-align: center; color: white;
      font-weight: bold; font-size: 12px;
      text-shadow: 1px 1px 0 #000;
    }

    #reset-btn {
      bottom: 20px; right: 20px;
      width: 40px; height: 40px;
      background: rgba(255,0,0,0.5);
      border: 2px solid white;
      border-radius: 8px;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      cursor: pointer;
    }
  </style>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
</head>
<body>

<div id="hud">
  <div class="hud-row"><span class="hud-label">SPD:</span> <span id="speed-display">0</span> kts</div>
  <div class="hud-row"><span class="hud-label">ALT:</span> <span id="alt-display">0</span> ft</div>
  <div class="hud-row"><span class="hud-label">HDG:</span> <span id="hdg-display">0</span>°</div>
  <div class="hud-row"><span class="hud-label">THR:</span> <span id="thr-display">0</span>%</div>
  <div class="hud-row"><span class="hud-label">VSI:</span> <span id="vsi-display">0</span> fpm</div>
  <div class="hud-row"><span class="hud-label">AOA:</span> <span id="aoa-display">0</span>°</div>
  <div class="hud-row"><span class="hud-label">G:</span> <span id="g-display">1.0</span></div>
  <div class="hud-row"><span class="hud-label">GEAR:</span> <span id="gear-display">DN</span></div>
  <div id="brake-warning" class="warning">BRAKE</div>
  <div id="stall-warning" class="warning">STALL</div>
</div>

<div id="controls-help">
  <b>Controls:</b><br>
  <span class="key">W</span> / <span class="key">S</span> - Throttle (Hold W)<br>
  <span class="key">A</span> - Afterburner (Hold)<br>
  <span class="key">Space</span> - Air Brake / Wheel Brakes<br>
  <span class="key">G</span> - Toggle Landing Gear<br>
  Arrows - Pitch/Roll & Steering<br>
  <span class="key">Q</span> / <span class="key">E</span> - Rudder<br>
  <i>Hold Down Arrow at 110kts to Fly</i>
</div>

<div id="start-screen" onclick="startGame()">
  <h1>3D Flight Demo</h1>
  <p>Click to Start</p>
  <p>Use <span class="key">W</span> to Throttle Up</p>
  <p>Hold <span class="key">A</span> for Afterburner</p>
  <p>Hold <span class="key">Space</span> for Air Brake / Brakes</p>
  <p>Use <span class="key">G</span> for Landing Gear</p>
  <p>Use <span class="key">Arrows</span> to Steer/Fly</p>
  <button class="btn-start">START FLIGHT</button>
</div>

<div id="overlay-msg" onclick="resetPlane()">CRASH<br>Tap to Restart</div>

<div id="throttle-container" class="touch-control">
  <div id="throttle-label">THR</div>
  <div id="throttle-fill"></div>
</div>

<div id="reset-btn" class="touch-control" onclick="resetPlane()">R</div>

<div id="canvas-container"></div>

<script>
/* =========================
   Globals
========================= */
let scene, camera, renderer, clock;
let plane;
let gameActive = false;

let PHYSICS = {};
let sim = {};
let stallAudio = null;

const VISUALS = {
  colors: {
    fuselage: 0xb0b7c0,
    glass: 0x112244,
    tire: 0x111111,
    exhaust: 0x444444
  }
};

let input = { pitch: 0, roll: 0, yaw: 0, throttle: 0 };
let keys = {};

/* =========================
   World & Terrain
========================= */
const WORLD = {
  size: 40000,
  segments: 140,      // more detail = fewer “slope-only” mountains, still reasonable
  runwayY: 0.2,
  groundY: -0.05
};

const RUNWAY = {
  halfW: 80,
  halfL: 2100
};

// Valley “no mountains” area (spawn + runway corridor)
const SPAWN = {
  x: 0,
  z: 1200,
  flatRadius: 850,   // ~0.53 miles
  fade: 650
};

const VALLEY = {
  halfW: RUNWAY.halfW + 900,
  halfL: RUNWAY.halfL + 900,
  fadeW: 950,
  fadeL: 950,
  floorDrop: 3.0     // terrain is kept BELOW runway near valley
};

// Terrain sampling (to fix floating/sinking trees)
// We sample the *actual mesh* height+normal, so trees always sit on the rendered surface.
const TERRAIN = {
  ready: false,
  size: WORLD.size,
  seg: WORLD.segments,
  geo: null,         // PlaneGeometry in its ORIGINAL orientation (x,y with z as height)
  meshY: WORLD.groundY
};

function clamp01(v){ return v < 0 ? 0 : (v > 1 ? 1 : v); }

function sampleTerrainMeshHeightAndNormal(x, z) {
  // world x,z -> geometry local x,y
  const size = TERRAIN.size;
  const seg = TERRAIN.seg;
  const vertsPer = seg + 1;

  const u = clamp01((x / size) + 0.5);
  const v = clamp01((z / size) + 0.5);

  const fx = u * seg;
  const fz = v * seg;

  const x0 = Math.floor(fx), z0 = Math.floor(fz);
  const x1 = Math.min(x0 + 1, seg), z1 = Math.min(z0 + 1, seg);

  const tx = fx - x0;
  const tz = fz - z0;

  const pos = TERRAIN.geo.attributes.position;
  const nor = TERRAIN.geo.attributes.normal;

  function idx(ix, iz){ return iz * vertsPer + ix; }

  const i00 = idx(x0, z0), i10 = idx(x1, z0), i01 = idx(x0, z1), i11 = idx(x1, z1);

  const h00 = pos.getZ(i00), h10 = pos.getZ(i10), h01 = pos.getZ(i01), h11 = pos.getZ(i11);
  const h0 = h00 + (h10 - h00) * tx;
  const h1 = h01 + (h11 - h01) * tx;
  const hLocal = h0 + (h1 - h0) * tz;

  // normal in plane-geometry space
  const n00 = new THREE.Vector3(nor.getX(i00), nor.getY(i00), nor.getZ(i00));
  const n10 = new THREE.Vector3(nor.getX(i10), nor.getY(i10), nor.getZ(i10));
  const n01 = new THREE.Vector3(nor.getX(i01), nor.getY(i01), nor.getZ(i01));
  const n11 = new THREE.Vector3(nor.getX(i11), nor.getY(i11), nor.getZ(i11));

  const n0 = n00.lerp(n10, tx);
  const n1 = n01.lerp(n11, tx);
  const nLocal = n0.lerp(n1, tz).normalize();

  // terrain mesh is rotated -PI/2 about X, so rotate normal the same way to world space
  const nWorld = nLocal.applyEuler(new THREE.Euler(-Math.PI/2, 0, 0)).normalize();

  const worldH = TERRAIN.meshY + hLocal;
  return { h: worldH, n: nWorld };
}

/* =========================
   Deterministic hill features
========================= */
const HILLS = [];

function mulberry32(seed) {
  return function() {
    let t = seed += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

function smoothstep(edge0, edge1, x) {
  const t = THREE.MathUtils.clamp((x - edge0) / (edge1 - edge0), 0, 1);
  return t * t * (3 - 2 * t);
}

function rectBlend(ax, az, halfW, halfL, fadeW, fadeL) {
  const dx = Math.max(0, ax - halfW);
  const dz = Math.max(0, az - halfL);
  const fx = smoothstep(0, fadeW, dx);
  const fz = smoothstep(0, fadeL, dz);
  return Math.max(fx, fz);
}

function circleBlend(x, z, cx, cz, radius, fade) {
  const d = Math.max(0, Math.hypot(x - cx, z - cz) - radius);
  return smoothstep(0, fade, d);
}

function isOnRunwayXZ(x, z) {
  return (Math.abs(x) < RUNWAY.halfW && Math.abs(z) < RUNWAY.halfL);
}

function valleyBlend(x, z) {
  const ax = Math.abs(x);
  const az = Math.abs(z);
  const bRect = rectBlend(ax, az, VALLEY.halfW, VALLEY.halfL, VALLEY.fadeW, VALLEY.fadeL);
  const bCirc = circleBlend(x, z, SPAWN.x, SPAWN.z, SPAWN.flatRadius, SPAWN.fade);
  return Math.min(bRect, bCirc); // 0 near valley/spawn, -> 1 out in mountains
}

function initHillFeatures() {
  HILLS.length = 0;
  const rand = mulberry32(1337);
  const count = 44; // keep pretty, not too heavy

  for (let i = 0; i < count; i++) {
    let x = 0, z = 0, tries = 0;

    while (tries++ < 60) {
      x = (rand() - 0.5) * 15000;
      z = (rand() - 0.5) * 15000;

      // keep features away from runway corridor + spawn valley
      if (Math.abs(x) < (VALLEY.halfW + VALLEY.fadeW) && Math.abs(z) < (VALLEY.halfL + VALLEY.fadeL)) continue;
      const dx = x - SPAWN.x, dz = z - SPAWN.z;
      if (Math.hypot(dx, dz) < (SPAWN.flatRadius + SPAWN.fade)) continue;

      break;
    }

    const radius = 260 + rand() * 1050;
    const height = 55 + Math.pow(rand(), 0.35) * 185;
    HILLS.push({ x, z, radius, height });
  }
}

function baseTerrainRaw(x, z) {
  const size = WORLD.size;
  const nx = x / size;
  const nz = z / size;

  const low  = Math.sin(nx * Math.PI * 4.0) * Math.cos(nz * Math.PI * 3.0) * 40;
  const mid  = Math.sin(nx * 2.3) * Math.sin(nz * 2.8) * 22;
  const hi   = Math.sin(nx * 10.0) * Math.cos(nz * 9.0) * 7;

  const ridge = 1.0 - Math.abs(Math.sin(nx * Math.PI * 3.6) * Math.cos(nz * Math.PI * 3.1));
  const ridgeShaped = Math.pow(ridge, 2.2) * 55;

  return (low + mid + hi) + ridgeShaped;
}

function featureHillsRaw(x, z) {
  let h = 0;
  for (let i = 0; i < HILLS.length; i++) {
    const f = HILLS[i];
    const dx = x - f.x;
    const dz = z - f.z;
    const d2 = dx*dx + dz*dz;
    const r2 = f.radius * f.radius;
    const w = Math.exp(-d2 / (2 * r2));
    h += f.height * w;
  }
  return h;
}

// Analytic height used to BUILD the mesh
function terrainWorldHeightOffRunway_Analytic(x, z) {
  const raw = WORLD.groundY + baseTerrainRaw(x, z) + featureHillsRaw(x, z);
  const valleyFloor = WORLD.runwayY - VALLEY.floorDrop;
  const b = valleyBlend(x, z);
  return THREE.MathUtils.lerp(valleyFloor, raw, b);
}

// Terrain mesh stays under runway
function getTerrainMeshWorldHeight_Analytic(x, z) {
  if (isOnRunwayXZ(x, z)) return WORLD.runwayY - VALLEY.floorDrop;
  return terrainWorldHeightOffRunway_Analytic(x, z);
}

/* =========================
   Ground height for physics/HUD
   (After we build the terrain mesh, we sample the mesh -> fixes floating/sinking trees AND ground contact mismatch)
========================= */
function getGroundHeight(x, z) {
  if (isOnRunwayXZ(x, z)) return WORLD.runwayY;
  if (TERRAIN.ready) return sampleTerrainMeshHeightAndNormal(x, z).h;
  return terrainWorldHeightOffRunway_Analytic(x, z);
}

/* =========================
   Start / Init
========================= */
function startGame() {
  document.getElementById('start-screen').style.display = 'none';
  gameActive = true;
  resetPlane();

  if (!stallAudio) {
    stallAudio = new Audio("stall_warning.mp3");
    stallAudio.loop = true;
    stallAudio.volume = 0.8;
  }
}

function init() {
  PHYSICS = {
    mass: 3500,
    gravity: 9.81,
    airDensity: 1.225,
    wingArea: 24.0,
    dragCoeffZero: 0.020,
    inducedDragFactor: 0.06,
    liftSlope: 7.5,
    maxLiftCoeff: 1.6,
    stallAngle: 0.45,
    wingIncidence: 0.02,
    maxThrust: 70000,
    momentInertia: new THREE.Vector3(12000, 15000, 12000),
    wheelFriction: 0.09,
    suspensionStiffness: 65000,
    suspensionDamping: 4000
  };

  sim = {
    pos: new THREE.Vector3(SPAWN.x, WORLD.runwayY + 1.35, SPAWN.z),
    vel: new THREE.Vector3(0, 0, 0),
    quat: new THREE.Quaternion(),
    angularVel: new THREE.Vector3(0, 0, 0),
    crashed: false,
    stalled: false,
    onGround: true,
    gearDown: true,
    afterburner: false,
    airBrake: false,
    alpha: 0,
    gLoad: 1.0
  };

  initHillFeatures();

  const container = document.getElementById('canvas-container');
  clock = new THREE.Clock();

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87CEEB);
  scene.fog = new THREE.Fog(0xbfd5ff, 4500, 26000);

  renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.5));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.05;
  container.appendChild(renderer.domElement);

  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 30000);

  // Sky
  const skyGeo = new THREE.SphereGeometry(12000, 32, 15);
  const skyMat = new THREE.ShaderMaterial({
    side: THREE.BackSide,
    uniforms: {
      topColor: { value: new THREE.Color(0x6fb6ff) },
      bottomColor: { value: new THREE.Color(0xf5fbff) },
      offset: { value: 33 },
      exponent: { value: 0.6 }
    },
    vertexShader: `
      varying vec3 vWorldPosition;
      void main() {
        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
        vWorldPosition = worldPosition.xyz;
        gl_Position = projectionMatrix * viewMatrix * worldPosition;
      }
    `,
    fragmentShader: `
      varying vec3 vWorldPosition;
      uniform vec3 topColor;
      uniform vec3 bottomColor;
      uniform float offset;
      uniform float exponent;
      void main() {
        float h = normalize(vWorldPosition + vec3(0.0, offset, 0.0)).y;
        float f = max(pow(max(h, 0.0), exponent), 0.0);
        vec3 col = mix(bottomColor, topColor, f);
        gl_FragColor = vec4(col, 1.0);
      }
    `
  });
  scene.add(new THREE.Mesh(skyGeo, skyMat));

  // Lights
  scene.add(new THREE.AmbientLight(0xffffff, 0.35));
  scene.add(new THREE.HemisphereLight(0xe6f1ff, 0x1e2a16, 0.35));

  const sun = new THREE.DirectionalLight(0xffffff, 1.15);
  sun.position.set(300, 600, 200);
  sun.castShadow = true;
  sun.shadow.mapSize.width = 2048;
  sun.shadow.mapSize.height = 2048;
  sun.shadow.camera.near = 10;
  sun.shadow.camera.far = 6000;
  sun.shadow.camera.left = -1200;
  sun.shadow.camera.right = 1200;
  sun.shadow.camera.top = 1200;
  sun.shadow.camera.bottom = -1200;
  scene.add(sun);

  createWorld();

  plane = createJetMesh();
  scene.add(plane);

  window.addEventListener('resize', onResize);
  document.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (e.code === 'KeyG') toggleGear();
  });
  document.addEventListener('keyup', e => keys[e.code] = false);

  animate();
}

function toggleGear() {
  sim.gearDown = !sim.gearDown;
  if (plane && plane.userData.gearGroup) plane.userData.gearGroup.visible = sim.gearDown;
}

/* =========================
   Inputs
========================= */
function updateInputs() {
  if (!gameActive) return;

  let kYaw = (keys['KeyQ'] ? 1 : 0) - (keys['KeyE'] ? 1 : 0);

  if (keys['KeyW']) input.throttle += 0.015;
  if (keys['KeyS']) input.throttle -= 0.02;
  input.throttle = THREE.MathUtils.clamp(input.throttle, 0, 1);

  sim.afterburner = keys['KeyA'];
  sim.airBrake    = keys['Space'];

  let keyPitchCmd = 0;
  if (keys['ArrowDown']) keyPitchCmd = 1;
  if (keys['ArrowUp']) keyPitchCmd = -1;

  let keyRollCmd = 0;
  if (keys['ArrowRight']) keyRollCmd = 1;
  if (keys['ArrowLeft']) keyRollCmd = -1;

  if (sim.onGround) {
    if (kYaw === 0 && Math.abs(keyRollCmd) > 0) kYaw = keyRollCmd * 0.5;
  }

  input.pitch = THREE.MathUtils.clamp(keyPitchCmd, -1, 1);
  input.roll  = THREE.MathUtils.clamp(keyRollCmd, -1, 1);
  input.yaw   = THREE.MathUtils.clamp(kYaw, -1, 1);
}

/* =========================
   Physics
========================= */
function updatePhysics(dt) {
  if (sim.crashed) return;

  updateInputs();

  const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(sim.quat);
  const up      = new THREE.Vector3(0, 1, 0).applyQuaternion(sim.quat);
  const right   = new THREE.Vector3(1, 0, 0).applyQuaternion(sim.quat);

  const speed = sim.vel.length();
  const localVel = sim.vel.clone().applyQuaternion(sim.quat.clone().invert());

  let alpha = PHYSICS.wingIncidence;
  if (speed > 1) alpha += Math.atan2(-localVel.y, -localVel.z);
  sim.alpha = alpha;
  sim.stalled = Math.abs(alpha) > PHYSICS.stallAngle;

  const q = 0.5 * PHYSICS.airDensity * (speed * speed);

  let cl = PHYSICS.liftSlope * alpha;
  cl = THREE.MathUtils.clamp(cl, -PHYSICS.maxLiftCoeff, PHYSICS.maxLiftCoeff);

  let groundEffect = 1.0;
  if (sim.pos.y < 5.0) groundEffect = 1.2;

  const liftForce = up.clone().multiplyScalar(q * PHYSICS.wingArea * cl * groundEffect);

  const cd = PHYSICS.dragCoeffZero + (PHYSICS.inducedDragFactor * cl * cl);
  let dragMag = q * PHYSICS.wingArea * cd;
  if (sim.airBrake) dragMag *= 15.0;
  const dragForce = (speed > 0.1) ? sim.vel.clone().normalize().negate().multiplyScalar(dragMag) : new THREE.Vector3();

  let currentThrottle = input.throttle;
  let abBoost = 1.0;
  if (sim.airBrake) currentThrottle = 0;
  else if (sim.afterburner) { currentThrottle = 1.1; abBoost = 2.0; }

  const thrustFactor = Math.max(0.4, 1 - (speed / 350));
  const thrustForce = forward.clone().multiplyScalar(currentThrottle * PHYSICS.maxThrust * thrustFactor * abBoost);

  // Visuals: afterburners + airbrakes
  if (plane) {
    if (plane.userData.afterburners) {
      const speedFactor = THREE.MathUtils.clamp(speed / 250, 0, 1.2);
      plane.userData.afterburners.forEach((ab, idx) => {
        ab.visible = sim.afterburner;
        if (!sim.afterburner) return;
        const flicker = 0.8 + Math.random() * 0.4;
        const base = (idx === 0) ? 1.0 : 0.6;
        const s = base * (1.0 + 0.6 * speedFactor) * flicker;
        if (idx === 0) ab.scale.set(s, s, s * 1.8);
        else ab.scale.set(s * 0.6, s * 0.6, s * 1.4);
      });
    }
    const brakeSpeed = 5.0 * dt;
    const targetRot = sim.airBrake ? 0.9 : 0;
    if (plane.userData.airBrakeL) plane.userData.airBrakeL.rotation.y += (targetRot - plane.userData.airBrakeL.rotation.y) * brakeSpeed;
    if (plane.userData.airBrakeR) plane.userData.airBrakeR.rotation.y += (-targetRot - plane.userData.airBrakeR.rotation.y) * brakeSpeed;
  }

  const gravityForce = new THREE.Vector3(0, -PHYSICS.gravity * PHYSICS.mass, 0);

  const totalForce = new THREE.Vector3()
    .add(liftForce)
    .add(dragForce)
    .add(thrustForce)
    .add(gravityForce);

  // Ground contact (use mesh-sampled height so it matches visuals)
  const gearHeight  = 1.35;
  const bellyHeight = 0.5;

  let groundH = getGroundHeight(sim.pos.x, sim.pos.z);
  const wasOnGround = sim.onGround;

  let suspensionTorque = 0;

  if (sim.gearDown) {
    const contactY = groundH + gearHeight;
    sim.onGround = (sim.pos.y <= contactY);

    if (sim.onGround) {
      if (sim.pos.y < contactY) sim.pos.y = contactY;

      if (!wasOnGround && plane && plane.userData.dust) {
        const touchdownSpeed = sim.vel.length();
        plane.userData.dust.material.opacity = THREE.MathUtils.clamp(touchdownSpeed / 60, 0.2, 0.8);

        const trackDirLocal = sim.vel.clone(); trackDirLocal.y = 0;
        trackDirLocal.applyQuaternion(sim.quat.clone().invert());
        if (trackDirLocal.lengthSq() > 0.1) {
          trackDirLocal.normalize();
          plane.userData.dust.rotation.y = Math.atan2(trackDirLocal.x, trackDirLocal.z);
        }
      }

      if (sim.vel.y < 0) {
        sim.vel.y = 0;
        if (totalForce.y < 0) totalForce.y = 0;
      }

      const normalForce = Math.max(0, PHYSICS.mass * PHYSICS.gravity - liftForce.y);
      const frictionMag = normalForce * PHYSICS.wheelFriction;

      if (speed > 0.1) totalForce.add(sim.vel.clone().normalize().negate().multiplyScalar(frictionMag));
      if (sim.airBrake && speed > 0.5) totalForce.add(sim.vel.clone().normalize().negate().multiplyScalar(normalForce * 0.6));

      const sideVel = sim.vel.dot(right);
      totalForce.add(right.clone().multiplyScalar(-sideVel * 2.0 * PHYSICS.mass * dt));

      if (speed > 1) sim.angularVel.y += input.yaw * 0.8 * dt;

      const euler = new THREE.Euler().setFromQuaternion(sim.quat, 'YXZ');
      if (euler.x < 0) {
        suspensionTorque += -euler.x * PHYSICS.suspensionStiffness;
        suspensionTorque -= sim.angularVel.x * PHYSICS.suspensionDamping;
      } else if (euler.x > 0.3) {
        suspensionTorque += -(euler.x - 0.3) * PHYSICS.suspensionStiffness;
      }
    }
  } else {
    sim.onGround = false;
    if (sim.pos.y < groundH + bellyHeight) {
      sim.crashed = true;
      document.getElementById('overlay-msg').innerHTML = "CRASH<br>Click to Reset";
      document.getElementById('overlay-msg').style.display = 'block';
      return;
    }
  }

  // Torque
  const controlScale = (q * PHYSICS.wingArea) / 2500;

  let yawStability = 0;
  if (speed > 50) yawStability = -localVel.x * 6.25 * controlScale;

  const stabilityPitch = -alpha * 40000;
  const controlPitch = input.pitch * 45000;

  const effectiveQ = Math.max(q, 100);
  let pitchTorque = (stabilityPitch + controlPitch) * (effectiveQ / 2000);
  pitchTorque += suspensionTorque;

  const controlRoll = -input.roll * 1750 * controlScale;
  const controlYaw  = (input.yaw * 2000 * controlScale) + yawStability;

  const torqueLocal = new THREE.Vector3(pitchTorque, controlYaw, controlRoll);

  // G load
  const accelNoDt = totalForce.clone().divideScalar(PHYSICS.mass);
  const properAccel = accelNoDt.clone().sub(new THREE.Vector3(0, -PHYSICS.gravity, 0));
  sim.gLoad = THREE.MathUtils.clamp(properAccel.dot(up) / PHYSICS.gravity, -3, 9);

  // Integrate
  sim.vel.add(totalForce.divideScalar(PHYSICS.mass).multiplyScalar(dt));
  sim.pos.add(sim.vel.clone().multiplyScalar(dt));

  const angAccel = new THREE.Vector3(
    torqueLocal.x / PHYSICS.momentInertia.x,
    torqueLocal.y / PHYSICS.momentInertia.y,
    torqueLocal.z / PHYSICS.momentInertia.z
  );
  sim.angularVel.multiplyScalar(1.0 - (2.0 * dt));
  sim.angularVel.add(angAccel.multiplyScalar(dt));

  const rotMag = sim.angularVel.length();
  if (rotMag > 0.0001) {
    const deltaRot = new THREE.Quaternion().setFromAxisAngle(sim.angularVel.clone().normalize(), rotMag * dt);
    sim.quat.multiply(deltaRot).normalize();
  }

  if (sim.onGround) {
    const euler = new THREE.Euler().setFromQuaternion(sim.quat, 'YXZ');
    euler.z *= 0.95;
    sim.quat.setFromEuler(euler);
    sim.angularVel.z *= 0.8;
  }

  // Vapor
  if (plane && plane.userData.vaporL) {
    const aoaStrength = THREE.MathUtils.clamp(Math.abs(sim.alpha) / PHYSICS.stallAngle, 0, 1);
    const speedFactor = THREE.MathUtils.clamp(speed / 120, 0, 1);
    const vaporOpacity = aoaStrength * speedFactor;

    plane.userData.vaporL.material.opacity = vaporOpacity;
    plane.userData.vaporR.material.opacity = vaporOpacity;

    if (speed > 1) {
      const flowLocal = sim.vel.clone().applyQuaternion(sim.quat.clone().invert()).normalize().negate();
      const vaporQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), flowLocal);
      plane.userData.vaporL.quaternion.copy(vaporQuat);
      plane.userData.vaporR.quaternion.copy(vaporQuat);
    }
  }

  // Dust fade
  if (plane && plane.userData.dust) {
    plane.userData.dust.material.opacity *= 0.75;
    plane.userData.dust.material.opacity -= 0.6 * dt;
    if (plane.userData.dust.material.opacity < 0) plane.userData.dust.material.opacity = 0;
  }

  plane.position.copy(sim.pos);
  plane.quaternion.copy(sim.quat);
}

/* =========================
   HUD / Camera / Reset
========================= */
function updateHUD() {
  if (!sim.vel) return;

  const spd = Math.round(sim.vel.length() * 1.9438);

  const groundBelow = getGroundHeight(sim.pos.x, sim.pos.z);
  const alt = Math.round((sim.pos.y - (groundBelow + 1.35)) * 3.2808);

  const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(sim.quat);
  let hdg = Math.round(Math.atan2(-fwd.x, -fwd.z) * 180 / Math.PI);
  if (hdg < 0) hdg += 360;

  const vsi = Math.round(sim.vel.y * 60 * 3.2808);
  const aoaDeg = Math.round((sim.alpha || 0) * 57.2958);
  const gLoad = sim.gLoad || 1.0;

  document.getElementById('speed-display').innerText = spd;
  document.getElementById('alt-display').innerText = alt;
  document.getElementById('hdg-display').innerText = hdg;

  let throttleVal = Math.round(input.throttle * 100);
  const thrEl = document.getElementById('thr-display');

  if (sim.airBrake) {
    throttleVal = 0;
    thrEl.style.color = '#fa0';
    thrEl.style.textShadow = 'none';
  } else if (sim.afterburner) {
    throttleVal = 110;
    thrEl.style.color = 'red';
    thrEl.style.textShadow = '0 0 5px red';
  } else {
    thrEl.style.color = '#0f0';
    thrEl.style.textShadow = 'none';
  }
  thrEl.innerText = throttleVal;

  document.getElementById('vsi-display').innerText = vsi;
  document.getElementById('aoa-display').innerText = aoaDeg;
  document.getElementById('g-display').innerText = gLoad.toFixed(1);

  document.getElementById('gear-display').innerText = sim.gearDown ? "DWN" : "UP";
  document.getElementById('gear-display').style.color = sim.gearDown ? "#0f0" : "#fa0";

  document.getElementById('stall-warning').style.display = sim.stalled ? 'block' : 'none';
  document.getElementById('brake-warning').style.display = (sim.airBrake && sim.onGround) ? 'block' : 'none';

  let barHeight = input.throttle * 100;
  let barColor = '#ffcc00';
  if (sim.airBrake) barHeight = 0;
  else if (sim.afterburner) { barHeight = 100; barColor = 'red'; }

  document.getElementById('throttle-fill').style.height = barHeight + '%';
  document.getElementById('throttle-fill').style.backgroundColor = barColor;

  if (stallAudio) {
    if (sim.stalled) {
      if (stallAudio.paused) {
        stallAudio.currentTime = 0;
        stallAudio.play().catch(()=>{});
      }
    } else {
      if (!stallAudio.paused) stallAudio.pause();
    }
  }
}

function updateCamera() {
  if (!sim.pos) return;
  const offset = new THREE.Vector3(0, 6, 28).applyQuaternion(sim.quat);
  const target = sim.pos.clone().add(offset);
  if (target.y < 2) target.y = 2;
  camera.position.lerp(target, 0.1);
  camera.lookAt(sim.pos.clone().add(new THREE.Vector3(0,0,0).applyQuaternion(sim.quat)));
}

function resetPlane() {
  sim.pos.set(SPAWN.x, WORLD.runwayY + 1.35, SPAWN.z);
  sim.vel.set(0, 0, 0);
  sim.quat.set(0, 0, 0, 1);
  sim.angularVel.set(0, 0, 0);

  sim.crashed = false;
  sim.stalled = false;
  sim.onGround = true;
  sim.gearDown = true;
  sim.afterburner = false;
  sim.airBrake = false;
  sim.alpha = 0;
  sim.gLoad = 1.0;

  if (plane) {
    if (plane.userData.gearGroup) plane.userData.gearGroup.visible = true;
    if (plane.userData.airBrakeL) plane.userData.airBrakeL.rotation.y = 0;
    if (plane.userData.airBrakeR) plane.userData.airBrakeR.rotation.y = 0;
    if (plane.userData.dust) plane.userData.dust.material.opacity = 0;
  }

  input.throttle = 0;
  input.pitch = 0;
  input.roll = 0;
  input.yaw = 0;

  document.getElementById('throttle-fill').style.height = '0%';
  document.getElementById('overlay-msg').style.display = 'none';
}

/* =========================
   Jet Mesh
========================= */
function createJetMesh() {
  const root = new THREE.Group();

  const matBody = new THREE.MeshStandardMaterial({ color: VISUALS.colors.fuselage, metalness: 0.7, roughness: 0.28 });
  const matGlass = new THREE.MeshPhysicalMaterial({
    color: VISUALS.colors.glass,
    metalness: 0.0, roughness: 0.1,
    transparent: true, opacity: 0.5, transmission: 0.7,
    clearcoat: 1.0, clearcoatRoughness: 0.15
  });
  const matExhaust = new THREE.MeshStandardMaterial({
    color: VISUALS.colors.exhaust, metalness: 0.9, roughness: 0.35,
    emissive: 0x111111, emissiveIntensity: 0.4
  });

  const fuse = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.6, 12, 24), matBody);
  fuse.rotation.x = -Math.PI/2; fuse.castShadow = true; root.add(fuse);

  const nose = new THREE.Mesh(new THREE.ConeGeometry(0.6, 3, 24), matBody);
  nose.rotation.x = -Math.PI/2; nose.position.z = -7.5; nose.castShadow = true; root.add(nose);

  const cockpit = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 1.5, 8, 16), matGlass);
  cockpit.rotation.x = -Math.PI/2; cockpit.position.set(0, 0.8, -3); cockpit.castShadow = true; root.add(cockpit);

  const airBrakeGeo = new THREE.BoxGeometry(0.12, 0.6, 1.5);
  airBrakeGeo.translate(0, 0, 0.75);

  const brakeL = new THREE.Mesh(airBrakeGeo, matBody);
  brakeL.position.set(0.9, 0, 4.2); brakeL.castShadow = true; root.add(brakeL);

  const brakeR = new THREE.Mesh(airBrakeGeo, matBody);
  brakeR.position.set(-0.9, 0, 4.2); brakeR.castShadow = true; root.add(brakeR);

  root.userData.airBrakeL = brakeL;
  root.userData.airBrakeR = brakeR;

  const wingShape = new THREE.Shape();
  const ww = 6, hh = 4, rr = 0.6;
  wingShape.absarc(ww/2 - rr, hh/2 - rr, rr, 0, Math.PI/2, false);
  wingShape.absarc(-ww/2 + rr, hh/2 - rr, rr, Math.PI/2, Math.PI, false);
  wingShape.absarc(-ww/2 + rr, -hh/2 + rr, rr, Math.PI, Math.PI*1.5, false);
  wingShape.absarc(ww/2 - rr, -hh/2 + rr, rr, Math.PI*1.5, Math.PI*2, false);

  const wingGeo = new THREE.ExtrudeGeometry(wingShape, {
    depth: 0.09, bevelEnabled: true, bevelThickness: 0.03, bevelSize: 0.06, bevelSegments: 4
  });
  wingGeo.center(); wingGeo.rotateX(Math.PI/2);

  const wingL = new THREE.Mesh(wingGeo, matBody);
  wingL.position.set(2.5, 0, 1); wingL.rotation.y = -0.5; wingL.castShadow = true; root.add(wingL);

  const wingR = new THREE.Mesh(wingGeo, matBody);
  wingR.position.set(-2.5, 0, 1); wingR.rotation.y = 0.5; wingR.castShadow = true; root.add(wingR);

  const exMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.6, 0.8, 20), matExhaust);
  exMesh.rotation.x = -Math.PI/2; exMesh.position.set(0, 0, 6.2); exMesh.castShadow = true; root.add(exMesh);

  const outerGeo = new THREE.ConeGeometry(0.5, 4.0, 16, 1, true);
  outerGeo.translate(0, 2.0, 0); outerGeo.rotateX(Math.PI/2);

  const flameOuter = new THREE.Mesh(outerGeo, new THREE.MeshBasicMaterial({
    color: 0xffaa33, transparent: true, opacity: 0.55,
    blending: THREE.AdditiveBlending, depthWrite: false
  }));
  flameOuter.position.set(0, 0, 6.6); flameOuter.visible = false; root.add(flameOuter);

  const innerGeo = new THREE.ConeGeometry(0.3, 3.0, 16, 1, true);
  innerGeo.translate(0, 1.5, 0); innerGeo.rotateX(Math.PI/2);

  const flameInner = new THREE.Mesh(innerGeo, new THREE.MeshBasicMaterial({
    color: 0x66c9ff, transparent: true, opacity: 0.8,
    blending: THREE.AdditiveBlending, depthWrite: false
  }));
  flameInner.position.set(0, 0, 6.7); flameInner.visible = false; root.add(flameInner);

  root.userData.afterburners = [flameOuter, flameInner];

  const tail = new THREE.Mesh(new THREE.BoxGeometry(0.12, 3.1, 3), matBody);
  tail.position.set(0, 1.5, 5.1); tail.rotation.x = 0.55; tail.castShadow = true; root.add(tail);

  const hStab = new THREE.Mesh(new THREE.BoxGeometry(3.7, 0.12, 2.1), matBody);
  hStab.position.set(0, 0.25, 5.6); hStab.rotation.x = -0.1; hStab.castShadow = true; root.add(hStab);

  const gearGroup = new THREE.Group();
  root.add(gearGroup);
  root.userData.gearGroup = gearGroup;

  const tireGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.25, 16);
  tireGeo.rotateZ(Math.PI/2);
  const tireMat = new THREE.MeshStandardMaterial({ color: VISUALS.colors.tire, roughness: 0.9, metalness: 0.0 });

  const noseWheel = new THREE.Mesh(tireGeo, tireMat);
  noseWheel.position.set(0, -1.2, -5); noseWheel.castShadow = true; gearGroup.add(noseWheel);

  const mainWheelL = new THREE.Mesh(tireGeo, tireMat);
  mainWheelL.position.set(1.4, -1.2, 1); mainWheelL.castShadow = true; gearGroup.add(mainWheelL);

  const mainWheelR = new THREE.Mesh(tireGeo, tireMat);
  mainWheelR.position.set(-1.4, -1.2, 1); mainWheelR.castShadow = true; gearGroup.add(mainWheelR);

  const vaporMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.0, depthWrite: false });
  const vaporGeo = new THREE.PlaneGeometry(2, 0.4);

  const vaporL = new THREE.Mesh(vaporGeo, vaporMat);
  vaporL.position.set(3.6, 0, 1.8); vaporL.rotation.y = Math.PI/2; root.add(vaporL);

  const vaporR = new THREE.Mesh(vaporGeo, vaporMat.clone());
  vaporR.position.set(-3.6, 0, 1.8); vaporR.rotation.y = -Math.PI/2; root.add(vaporR);

  root.userData.vaporL = vaporL;
  root.userData.vaporR = vaporR;

  const dustGeo = new THREE.PlaneGeometry(6, 3);
  dustGeo.rotateX(-Math.PI/2);
  const dust = new THREE.Mesh(dustGeo, new THREE.MeshBasicMaterial({ color: 0xaaaaaa, transparent: true, opacity: 0.0, depthWrite: false }));
  dust.position.set(0, -1.2, 1);
  root.add(dust);
  root.userData.dust = dust;

  return root;
}

/* =========================
   World (Terrain + Grid + Runway + Trees)
   FIXES:
   - Terrain mesh is built from analytic height.
   - TERRAIN stores the geometry + normals.
   - Trees are placed using mesh-sampled height+normal (no floating / no sinking into mountains).
   - Trees are slightly offset along the normal so they don't clip.
========================= */
function createWorld() {
  const size = WORLD.size;
  const segments = WORLD.segments;

  // --- Terrain mesh geometry (keep this exact geo for sampling) ---
  const groundGeo = new THREE.PlaneGeometry(size, size, segments, segments);
  const pos = groundGeo.attributes.position;

  for (let i = 0; i < pos.count; i++) {
    const x = pos.getX(i);
    const zPlane = pos.getY(i); // becomes world Z after rotate

    const worldH = getTerrainMeshWorldHeight_Analytic(x, zPlane);
    const localZ = worldH - WORLD.groundY; // mesh sits at groundY
    pos.setZ(i, localZ);
  }
  pos.needsUpdate = true;
  groundGeo.computeVertexNormals();

  // Store for sampling
  TERRAIN.ready = true;
  TERRAIN.geo = groundGeo;
  TERRAIN.seg = segments;
  TERRAIN.size = size;
  TERRAIN.meshY = WORLD.groundY;

  // Terrain
  const ground = new THREE.Mesh(groundGeo, new THREE.MeshStandardMaterial({
    color: 0x365c3c, roughness: 0.95, metalness: 0.0
  }));
  ground.rotation.x = -Math.PI/2;
  ground.position.y = WORLD.groundY;
  ground.receiveShadow = true;
  scene.add(ground);

  // Terrain wire “grid”
  const groundGrid = new THREE.Mesh(groundGeo.clone(), new THREE.MeshBasicMaterial({
    color: 0x111111,
    wireframe: true,
    transparent: true,
    opacity: 0.22,
    depthWrite: false,
    polygonOffset: true,
    polygonOffsetFactor: -1,
    polygonOffsetUnits: -1
  }));
  groundGrid.rotation.x = -Math.PI/2;
  groundGrid.position.y = WORLD.groundY + 0.02;
  groundGrid.renderOrder = 2;
  scene.add(groundGrid);

  // Runway (flat and always above terrain)
  const runway = new THREE.Mesh(new THREE.PlaneGeometry(60, 3500), new THREE.MeshStandardMaterial({
    color: 0x222428, roughness: 0.8, metalness: 0.1
  }));
  runway.rotation.x = -Math.PI/2;
  runway.position.y = WORLD.runwayY;
  runway.receiveShadow = true;
  runway.castShadow = true;
  scene.add(runway);

  // Markings
  const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
  for (let z = -1600; z <= 1600; z += 200) {
    const mark = new THREE.Mesh(new THREE.PlaneGeometry(2.2, 40), lineMat);
    mark.rotation.x = -Math.PI/2;
    mark.position.set(0, WORLD.runwayY + 0.05, z);
    scene.add(mark);
  }
  const edgeMat = new THREE.MeshBasicMaterial({ color: 0xe0e0e0 });
  const leftEdge = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 3500), edgeMat);
  leftEdge.rotation.x = -Math.PI/2;
  leftEdge.position.set(-29.5, WORLD.runwayY + 0.04, 0);
  scene.add(leftEdge);
  const rightEdge = leftEdge.clone();
  rightEdge.position.x = 29.5;
  scene.add(rightEdge);

  // --- Trees (instanced) placed ON THE MESH surface ---
  const treeCount = 520;

  const trunkGeo = new THREE.CylinderGeometry(0.5, 0.7, 6, 6);
  const trunkMat = new THREE.MeshLambertMaterial({ color: 0x4a3018 });

  const leafGeo = new THREE.ConeGeometry(5, 16, 10);
  const leafMat = new THREE.MeshLambertMaterial({ vertexColors: true });

  const trunkInst = new THREE.InstancedMesh(trunkGeo, trunkMat, treeCount);
  const leafInst  = new THREE.InstancedMesh(leafGeo, leafMat, treeCount);

  trunkInst.castShadow = false; trunkInst.receiveShadow = false;
  leafInst.castShadow = false;  leafInst.receiveShadow = false;

  const tmpMat = new THREE.Matrix4();
  const tmpPos = new THREE.Vector3();
  const tmpQuat = new THREE.Quaternion();
  const tmpScale = new THREE.Vector3();

  const up = new THREE.Vector3(0,1,0);

  let placed = 0, attempts = 0;
  while (placed < treeCount && attempts < treeCount * 16) {
    attempts++;

    const x = (Math.random() - 0.5) * 9500;
    const z = (Math.random() - 0.5) * 9500;

    // keep valley corridor clean-ish
    if (Math.abs(x) < (VALLEY.halfW - 120) && Math.abs(z) < (VALLEY.halfL - 120)) continue;
    if (isOnRunwayXZ(x, z)) continue;

    const s = 0.6 + Math.random() * 1.1;

    // sample mesh height+normal so no floating/sinking
    const sample = sampleTerrainMeshHeightAndNormal(x, z);
    const groundY = sample.h;
    const n = sample.n;

    // Avoid super-steep faces (prevents “half buried” on cliff sides)
    if (n.y < 0.62) continue;

    // Align tree to the surface normal a bit (reduces clipping into slopes)
    tmpQuat.setFromUnitVectors(up, n);

    // Tiny lift along normal to prevent z-fighting/clipping into the terrain
    const lift = 0.18 * s;

    tmpScale.set(s, s, s);

    // trunk height 6, centered => half height = 3
    tmpPos.set(x, groundY, z).add(n.clone().multiplyScalar((3.0 * s) + lift));
    tmpMat.compose(tmpPos, tmpQuat, tmpScale);
    trunkInst.setMatrixAt(placed, tmpMat);

    // leaves: cone height 16, centered => half height = 8
    tmpPos.set(x, groundY, z).add(n.clone().multiplyScalar((14.0 * s) + lift));
    tmpMat.compose(tmpPos, tmpQuat, tmpScale);
    leafInst.setMatrixAt(placed, tmpMat);

    const c = new THREE.Color().setHSL(0.15 + Math.random() * 0.2, 0.8, 0.28 + Math.random() * 0.22);
    leafInst.setColorAt(placed, c);

    placed++;
  }

  trunkInst.instanceMatrix.needsUpdate = true;
  leafInst.instanceMatrix.needsUpdate = true;
  if (leafInst.instanceColor) leafInst.instanceColor.needsUpdate = true;

  scene.add(trunkInst);
  scene.add(leafInst);
}

/* =========================
   Utils + Loop
========================= */
function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
  requestAnimationFrame(animate);
  const dt = Math.min(clock.getDelta(), 0.1);
  updatePhysics(dt);
  updateHUD();
  updateCamera();
  renderer.render(scene, camera);
}

window.addEventListener('load', init);
</script>
</body>
</html>
